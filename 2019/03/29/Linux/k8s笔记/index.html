<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="Kubernetes简介   引用：http://www.magedu.com   引用：https://draveness.me/  容器编排工具 docker 官方编排  docker compose	单机编排工具docker swarm	将多台 docker 提供的计算资源整合的接口，随后docker compose编排的时候只需要面向这个整合的接口进行编排就行，无论接口下有多少个主机。do">
<meta property="og:type" content="article">
<meta property="og:title" content="Kubernetes混乱笔记">
<meta property="og:url" content="https://yangjinheng.github.io/2019/03/29/Linux/k8s笔记/index.html">
<meta property="og:site_name" content="默默">
<meta property="og:description" content="Kubernetes简介   引用：http://www.magedu.com   引用：https://draveness.me/  容器编排工具 docker 官方编排  docker compose	单机编排工具docker swarm	将多台 docker 提供的计算资源整合的接口，随后docker compose编排的时候只需要面向这个整合的接口进行编排就行，无论接口下有多少个主机。do">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="c:/Users/LENOVO/AppData/Roaming/Typora/typora-user-images/1553775804312.png">
<meta property="og:image" content="c:/Users/LENOVO/AppData/Roaming/Typora/typora-user-images/1553776386074.png">
<meta property="og:image" content="c:/Users/LENOVO/AppData/Roaming/Typora/typora-user-images/1553776698329.png">
<meta property="og:updated_time" content="2019-04-03T14:52:20.469Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Kubernetes混乱笔记">
<meta name="twitter:description" content="Kubernetes简介   引用：http://www.magedu.com   引用：https://draveness.me/  容器编排工具 docker 官方编排  docker compose	单机编排工具docker swarm	将多台 docker 提供的计算资源整合的接口，随后docker compose编排的时候只需要面向这个整合的接口进行编排就行，无论接口下有多少个主机。do">
<meta name="twitter:image" content="c:/Users/LENOVO/AppData/Roaming/Typora/typora-user-images/1553775804312.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://yangjinheng.github.io/2019/03/29/Linux/k8s笔记/">





  <title>Kubernetes混乱笔记 | 默默</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?be46574a10a6c2b7f67e9c32a008cbd5";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">默默</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-个人日志">
          <a href="/categories/个人日志/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-github-alt"></i> <br>
            
            个人日志
          </a>
        </li>
      
        
        <li class="menu-item menu-item-kubernetes">
          <a href="/2019/03/29/Linux/k8s笔记/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-cog"></i> <br>
            
            Kubernetes
          </a>
        </li>
      
        
        <li class="menu-item menu-item-docker">
          <a href="/2018/07/10/Linux/Docker/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-fighter-jet"></i> <br>
            
            Docker
          </a>
        </li>
      
        
        <li class="menu-item menu-item-react">
          <a href="/2019/01/21/web/react/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-asterisk"></i> <br>
            
            React
          </a>
        </li>
      
        
        <li class="menu-item menu-item-css">
          <a href="/2019/01/02/web/css/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-dashboard"></i> <br>
            
            CSS
          </a>
        </li>
      
        
        <li class="menu-item menu-item-python">
          <a href="/categories/Python/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-laptop"></i> <br>
            
            Python
          </a>
        </li>
      
        
        <li class="menu-item menu-item-django">
          <a href="/2017/10/06/python/27.Django笔记/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-globe"></i> <br>
            
            Django
          </a>
        </li>
      
        
        <li class="menu-item menu-item-git">
          <a href="/2017/06/21/Linux/git/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-github"></i> <br>
            
            Git
          </a>
        </li>
      
        
        <li class="menu-item menu-item-mysql">
          <a href="/2017/01/20/Linux/MYSQL/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-table"></i> <br>
            
            MySQL
          </a>
        </li>
      
        
        <li class="menu-item menu-item-ansible">
          <a href="/2017/03/20/Linux/Ansible/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-download"></i> <br>
            
            Ansible
          </a>
        </li>
      
        
        <li class="menu-item menu-item-saltstack">
          <a href="/2018/01/10/Linux/SaltStack/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-sitemap"></i> <br>
            
            SaltStack
          </a>
        </li>
      

      
    </ul>
  

  
</nav>


 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yangjinheng.github.io/2019/03/29/Linux/k8s笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jin Heng">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="默默">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Kubernetes混乱笔记</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-29T00:00:00+08:00">
                2019-03-29
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/运维笔记/" itemprop="url" rel="index">
                    <span itemprop="name">运维笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="Kubernetes简介"><a href="#Kubernetes简介" class="headerlink" title="Kubernetes简介"></a>Kubernetes简介</h1><blockquote>
<p>  引用：<a href="http://www.magedu.com" target="_blank" rel="noopener">http://www.magedu.com</a></p>
<p>  引用：<a href="https://draveness.me/" target="_blank" rel="noopener">https://draveness.me/</a></p>
</blockquote>
<h2 id="容器编排工具"><a href="#容器编排工具" class="headerlink" title="容器编排工具"></a>容器编排工具</h2><ul>
<li>docker 官方编排</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker compose</span><br><span class="line">	单机编排工具</span><br><span class="line"></span><br><span class="line">docker swarm</span><br><span class="line">	将多台 docker 提供的计算资源整合的接口，随后docker compose编排的时候只需要面向这个整合的接口进行编排就行，无论接口下有多少个主机。</span><br><span class="line"></span><br><span class="line">docker mechine</span><br><span class="line">	将一个主机初始化为一个能够加入 docker swarm 集群中的预置程序</span><br></pre></td></tr></table></figure>
<ul>
<li>mesos</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">IDC操作系统，能将一个IDC提供的硬件资源，统一调度和分配，它只是一个资源分配工具，非能够直接托管容器的，所以它提供了以个能够直接编排框架，marathon。</span><br></pre></td></tr></table></figure>
<ul>
<li>kubernetes</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">目前最流行的容器编排工具，市场占有率最高</span><br></pre></td></tr></table></figure>
<h2 id="自动化运维"><a href="#自动化运维" class="headerlink" title="自动化运维"></a>自动化运维</h2><ul>
<li>CI</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">持续集成</span><br><span class="line">当程序员提交到 GITHUB ，Jenkins 会自动从 GITHUB 下载代码并构建，并部署到测试环境进行测试，如果测试没有问题，则提交到运维的共享存储上，运维需要手动部署到线上。</span><br></pre></td></tr></table></figure>
<ul>
<li>CD</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">持续交付（Delivery）、持续部署（Deplcoment）</span><br><span class="line"></span><br><span class="line">如果有一款工具能够在测试完成后自动触发并部署到生产环境，不需要运维再干预，那么这就是持续部署，这个过程就叫 DevOps。</span><br><span class="line"></span><br><span class="line">而当容器技术出现，这最后一部就可以实现自动化了，那么最后在测试完成后直接构建为镜像，然后把镜像运行为容器，就可以实现自动部署了。</span><br><span class="line"></span><br><span class="line">正是因为容器技术的出现，DevOps 实现了真正的落地。</span><br></pre></td></tr></table></figure>
<h2 id="kubernetes"><a href="#kubernetes" class="headerlink" title="kubernetes"></a>kubernetes</h2><p>是希腊语，翻译过来是：舵手的意思，是谷歌内部使用 Borg 的集群管理系统构建的，在 2014 年发布了第一个版本，目前开源并托管在GITHUB上。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">https://github.com/Kubernetes</span><br></pre></td></tr></table></figure>
<p>目前：AWS、阿里云、微软云，目前已经原生支持 K8S ，目前已经可以让用户直接部署云原生的服务。</p>
<p>Kubernetes 可以实现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- 自动装箱，自动修复，水平扩展，服务发现和负载均衡，自动发布和回滚</span><br><span class="line">- 密钥和配置管理、存储编排、批量处理执行</span><br></pre></td></tr></table></figure>
<h2 id="环境架构"><a href="#环境架构" class="headerlink" title="环境架构"></a>环境架构</h2><p>Kubernetes 是一个集群，整合多台计算机的计算能力，它是一种有中心节点模式的集群，在 K8S 集群中主机分为两种角色：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Master：集群的管理节点，有一个或者一组节点，一般3个足够了。</span><br><span class="line">nodes：提供计算资源的节点，就是运行容器的节点，可以扩展。</span><br></pre></td></tr></table></figure>
<p>客户端创建启动容器的请求交给 Master ，Master 上有一个<strong>调度器</strong>它能分析各 nodes 节点上的资源状态，找一个最适合运行用户容器的节点，并在这个节点上使用 Docker 启动这个容器，node 节点的 Docker 在启动容器时候会首先检查本地有没有镜像，如果没有就从仓库中 pull 然后运行。</p>
<p>那么仓库可以运行为容器，所以也可以托管在 Kubernetes 之上，其实 Kubernetes 可以托管自身，即自托管。</p>
<ul>
<li>ApiServer</li>
</ul>
<p>kubernetes 接收用户创建容器等请求的是 Kubernetes Cluster，那么它对外提供服务的接口就是一个 API 接口 ，这个接口需要编程来访问，或者通过编写好的客户端程序来访问，Kubernetes Master 上有一个组件就是 ApiServer，来接收客端请求，解析客户端请求。</p>
<ul>
<li>scheduler</li>
</ul>
<p>如果客户请求是运行一个容器，那么 Master 会使用调度器（scheduler）根据用户的请求来分配一个能够运行容器的 nodes 节点，例如：根据用户对资源要求，CPU、内存、来评估哪个 nodes 最合适运行。</p>
<p>大概的过程就是：首先是预选，从 nodes 中挑选出符合用户容器运行要求的，然后在这些预选结果中进行优选，选出最佳的适配 node。</p>
<ul>
<li>Controller（控制器）</li>
</ul>
<p>如果运行容器的节点宕机或者容器本身运行出现问题，kubernetes 能够在其他节点再启动一个一模一样的容器，这就是 Kubernetes 提供的自愈能力。</p>
<p>控制器就实现了监控它所负责的每一个容器的健康状态，一旦发现不健康了，那么控制器会向 Master 发送请求，Master 会再次由调度器挑选出合适的节点再次运行这个容器。</p>
<p>它能持续性探测所管理的容器，一旦不健康，或不符合用户定义的健康状态，就会由它发起来请求，来保证容器向用户希望的健康状态迁徙。</p>
<p>而 Kubernets 支持众多的控制器，支持容器健康的控制器只是其中一种。</p>
<ul>
<li>ControllerManager（制器管理器）</li>
</ul>
<p>在 Master 内置组件中有一个控制器管理器，它负责监视着每一个控制器，如果控制器不健康无法工作，那么由控制器管理器来确保控制器的健康，由于 Master 有多个，所以具有冗余性。</p>
<ul>
<li>Pod（原子调度单元，是容器的封装）</li>
</ul>
<p>在 Kubernetes 上调度的原子单元，Kubernetes 不直接调度容器，而是 Pod，Pod可以理解为容器的二次封装，可以由一个或者多个容器组成，多个容器共享同一个网络名称空间：NET、UTS、IPC。</p>
<p>同一个 POD 里的容器，还能共享同一个存储卷，存储卷可以属于 POD。</p>
<p>一般一个 POD 只运行一个容器，如果需要在POD放多个容器，那么一般有一个主容器，其他容器是为主容器提供服务的。</p>
<ul>
<li>node（工作节点）</li>
</ul>
<p>提供计算资源的节点，就是运行 Pod 的主机，Kubenetes Cluster 统一管理所有的 node 节点的计算资源，当用户请求创建资源的时候，可以检查目前集群还有没有资源可以运行用户的容器，这实现了统一调度统一管理的一个平台。</p>
<ul>
<li>label（标签）</li>
</ul>
<p>一个由 <code>key = value</code> 组成的标签，可以为 POD 打上一个标签。</p>
<ul>
<li>selecter（标签选择器）</li>
</ul>
<p>集群中运行的众多 POD ，前面提到一个控制器可以管理若干个 POD ，那么控制器如何从集群中运行的所有 POD 中挑选出来自己需要管理的 POD 呢？ </p>
<p>在创建一个 POD 的时候为 POD 打上一个标签，让程序可以通过这个标签来识别出来这个POD，还可以用来区分一组相同功能的POD，例如：创建四个nginx pod，可以给每个pod加一个 K/V类型的标签如：app=nginx，将来找出这四个 nginx pod，那么条件就是根据 拥有 key 为 app 的pod 并且 value 为 nginx 来挑出这组 POD。</p>
<p>标签不是 POD 唯一具有的机制，其他的组件同样可以有标签。</p>
<h2 id="组件总结"><a href="#组件总结" class="headerlink" title="组件总结"></a>组件总结</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Matser：主节点上运行的组件</span><br><span class="line">    ApiServer：提供一个可以接收用户请求的守护进程</span><br><span class="line">    Scheduler：接收用户请求后调度接收到的任务到指定的节点</span><br><span class="line">    Controller-Master：</span><br><span class="line">node：工作节点上的组件</span><br><span class="line">    kubelet：</span><br><span class="line">    docker：</span><br><span class="line">    kube-proxy：随时与 apiserver 进行通信</span><br></pre></td></tr></table></figure>
<h1 id="组件和附件"><a href="#组件和附件" class="headerlink" title="组件和附件"></a>组件和附件</h1><h2 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h2><p>这些控制器分别用于确保不同类型的 POD 资源运行于符合用户所期望的状态。</p>
<ul>
<li>RelicationController</li>
</ul>
<p>控制同一类 POD 对象的副本数量，实现程序的滚动更新，或者回滚的操作。</p>
<p>在滚动更新时候，允许临时超出规定的副本数量，</p>
<ul>
<li>RelicaSet</li>
</ul>
<p>副本集控制器，它不直接使用，它有一个声明式中心控制器 Deployment</p>
<ul>
<li>Deployment</li>
</ul>
<p>它只能管理无状态的应用。</p>
<p>这个控制器，支持二级控制器，例如：HPA（Horizontal Pod Autoscaler，水平 POD 自动伸缩控制器），当负载高的时候，自动启动更多的 POD。</p>
<ul>
<li>StatefulSet</li>
</ul>
<p>管理有状态的应用</p>
<ul>
<li>DaeminSet</li>
</ul>
<p>如果需要在每一个 node 上运行一个副本，而不是随意运行</p>
<ul>
<li>Job</li>
</ul>
<p>运行作业，时间不固定的操作，例如：备份、清理，临时启动一个 POD 来进行备份的任务，运行完成就结束了。</p>
<p>如果运行时候 JOB 挂了，那么需要重新启动起来，如果运行完成了则不需要再启动了。</p>
<ul>
<li>Cronjob</li>
</ul>
<p>和周期性作业</p>
<h2 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h2><p>为客户端提供一个稳定的访问入口，Service 靠标签选择器来关联 POD 的，只要 POD 上有相关的标签，那么就会被 Service 选中，作为 Service 的后端，Service 关联 POD 后会动态探测这个 POD 的 IP 地址和端口，并作为自己调度的后端。</p>
<p>总的来说客户端请求 Service 由 Service 代理至后端的 POD，所以客户端看到的始终是 Service 的地址。</p>
<p>K8S 上的 Service 不是一个应用程序，也不是一个组件，它是一个 iptables dnat 规则，或者 ipvs 规则，Service 只是规则，所以是 ping 不通的，但是它的确可以请求。</p>
<p>Service 作为 k8s 的对象来说，是有名称的，可以通过 Service 的名称解析为 Service 的 IP 地址。</p>
<ul>
<li>AddOns</li>
</ul>
<p>解析域名是由 DNS 来解析的，为 k8s 中提供域名解析这种基础服务，称之为基础架构 POD 也称为 k8s 附件，所以域名解析的 POD 就是 k8s 中的一种 AddOns。</p>
<p>而 k8s 中的 dns 附件，是动态的，例如：service 名称发生更改，就会自动触发 dns 中的解析记录的改变，如果手动修改 service 的地址，也会自动触发 DNS 解析记录的改变，所以客户端访问服务时，可以直接访问服务的名称。</p>
<h2 id="网络模型"><a href="#网络模型" class="headerlink" title="网络模型"></a>网络模型</h2><p>k8s 有三种网络：POD网络、集群网络、节点网络</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POD网络：所有 POD 处于同一个网络中</span><br><span class="line">集群网络：Service 是一个另外一个网络</span><br><span class="line">节点网络：node 节点也是另外一个网络</span><br></pre></td></tr></table></figure>
<p>所以，接入外部访问时候，请求首先到达 node 网络，然后 node 网络代理至 service 网络，service 根据 ipvs 规则来转发到 pod 网络中的 pod 上。</p>
<p>k8s 有三种通信：</p>
<p>同一个 POD 内的多个容器间的通信，可以直接通过 lo 通信</p>
<p>POD 与 POD 通信，所有 POD 都处于一个网络，可以跨 node 与另外的 POD 直接通信，因为使用了叠加网络。</p>
<p>POD 与 Service 通信，</p>
<h2 id="kube-proxy"><a href="#kube-proxy" class="headerlink" title="kube-proxy"></a>kube-proxy</h2><p>在 node 节点上运行的一个守护进程，它负责随时与 apiserver 进行通信，因为每个 pod 发生变化后需要保存在 apiserver 中，而 apiserver 发生改变后会生成一个通知事件，这个事件可以被任何关联的组件接收到，例如被 kube-proxy 一旦发现某个 service 后端的 pod 地址发生改变，那么就由 kube-proxy 负责在本地将地址写入 iptables 或者 ipvs 规则中。</p>
<p>所以 service 的管理是靠 kube-proxy 来实现的，当你创建一个 service ，那么就靠 kube-proxy 在每个节点上创建为 iptables 或者 ipvs 规则，每个 service 的变动也需要 kube-proxy 反应到规则上。</p>
<p>apiserver 需要保存各个 node 信息，它需要保存在 etcd 中。</p>
<h2 id="etcd"><a href="#etcd" class="headerlink" title="etcd"></a>etcd</h2><p>是一个键值存储的系统，与 redis 很想，但是 etcd 还有一些协调功能是 redis 所不具备的，它还有节点选举等功能，从这个角度来讲 etcd 更像 zookpeer。</p>
<p>由于整个集群的所有信息都保存在 etcd，所以 etcd 如果宕机，那么整个集群就挂了，因而 etcd 需要做高可用。</p>
<h2 id="flanel"><a href="#flanel" class="headerlink" title="flanel"></a>flanel</h2><p>托管为 k8s 的附件运行</p>
<p>node 网络：各节点之间进行通信</p>
<p>POD 网络：所有 node上的 POD 彼此之间通过叠加，或者直接路由方式通信</p>
<p>service 网络：由 kube-proxy 负责管控和生成</p>
<p><img src="C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1553775804312.png" alt="1553775804312"></p>
<h2 id="知识小结"><a href="#知识小结" class="headerlink" title="知识小结"></a>知识小结</h2><p><img src="C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1553776386074.png" alt="1553776386074"></p>
<ul>
<li>Master</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kube-scheduler             # 调度 pod</span><br><span class="line">kuber-controller-manager   # 管理 pod</span><br><span class="line">kube-apiserver             # 接收请求</span><br><span class="line">etcd                       # 集群状态存储，集群所有的组件的状态都保存在这里</span><br></pre></td></tr></table></figure>
<ul>
<li>node</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubelet                    # </span><br><span class="line">kube-proxy                 # </span><br><span class="line">docker                     # 容器引擎</span><br></pre></td></tr></table></figure>
<h1 id="安装集群"><a href="#安装集群" class="headerlink" title="安装集群"></a>安装集群</h1><h2 id="部署架构"><a href="#部署架构" class="headerlink" title="部署架构"></a>部署架构</h2><p><img src="C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1553776698329.png" alt="1553776698329"></p>
<p>节点网络：172.20.0.0/16</p>
<p>POD 网络：10.244.0.0/16</p>
<p>Service 网络：10.96.0.0/12</p>
<h2 id="安装-Master"><a href="#安装-Master" class="headerlink" title="安装 Master"></a>安装 Master</h2><h3 id="配置-kuberetes-安装源"><a href="#配置-kuberetes-安装源" class="headerlink" title="配置 kuberetes 安装源"></a>配置 kuberetes 安装源</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat &gt;&gt;/etc/yum.repos.d/kuberetes.repo&lt;&lt;EOF</span><br><span class="line">[kuberneres]</span><br><span class="line">name=Kubernetes</span><br><span class="line">baseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64/</span><br><span class="line">gpgcheck=0</span><br><span class="line">gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg</span><br><span class="line">enabled=1</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>
<h3 id="配置-docker-安装源"><a href="#配置-docker-安装源" class="headerlink" title="配置 docker 安装源"></a>配置 docker 安装源</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -o /etc/yum.repos.d/docker-ce.repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure>
<h3 id="安装-kubernetes"><a href="#安装-kubernetes" class="headerlink" title="安装 kubernetes"></a>安装 kubernetes</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install docker-ce kubelet kubeadm kubectl</span><br></pre></td></tr></table></figure>
<h3 id="配置-Docker"><a href="#配置-Docker" class="headerlink" title="配置 Docker"></a>配置 Docker</h3><ul>
<li>编辑docker，设置Docker下载镜像时候使用代理，注意本地使用：shadowsockets </li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /usr/lib/systemd/system/docker.service</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[Service]</span><br><span class="line">Environment=&quot;HTTPS_PROXY=10.0.0.2:1080&quot;</span><br><span class="line">Environment=&quot;NO_PROXY=127.0.0.0/8,172.16.0.0/16&quot;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure>
<h3 id="配置-ipvs"><a href="#配置-ipvs" class="headerlink" title="配置 ipvs"></a>配置 ipvs</h3><ul>
<li>在所有节点安装</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install ipvsadm ipset sysstat conntrack libseccomp</span><br></pre></td></tr></table></figure>
<ul>
<li>开启 ipvs 模块，编辑 /etc/modules-load.d/ipvs.conf，systemctl enable systemd-modules-load.service</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ip_vs_dh</span><br><span class="line">ip_vs_ftp</span><br><span class="line">ip_vs</span><br><span class="line">ip_vs_lblc</span><br><span class="line">ip_vs_lblcr</span><br><span class="line">ip_vs_lc</span><br><span class="line">ip_vs_nq</span><br><span class="line">ip_vs_pe_sip</span><br><span class="line">ip_vs_rr</span><br><span class="line">ip_vs_sed</span><br><span class="line">ip_vs_sh</span><br><span class="line">ip_vs_wlc</span><br><span class="line">ip_vs_wrr</span><br><span class="line">nf_conntrack_ipv4</span><br></pre></td></tr></table></figure>
<ul>
<li>检查 ipvs 模块</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lsmod | grep -e ip_vs -e nf_conntrack_ipv4</span><br></pre></td></tr></table></figure>
<h3 id="初始化-kubelet"><a href="#初始化-kubelet" class="headerlink" title="初始化 kubelet"></a>初始化 kubelet</h3><ul>
<li>确保如下两个内核功能为开启状态</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat &gt;&gt;/etc/sysctl.conf&lt;&lt;EOF</span><br><span class="line">net.bridge.bridge-nf-call-ip6tables = 1</span><br><span class="line">net.bridge.bridge-nf-call-iptables = 1</span><br><span class="line">net.ipv4.ip_forward = 1</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>
<ul>
<li>vim /etc/sysconfig/kubelet，关闭 swap 的警告，使用 ipvs 作为 service 的代理模型</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">KUBELET_EXTRA_ARGS=<span class="string">"--fail-swap-on=false"</span></span><br><span class="line">KUBE_PROXY_MODE=ipvs</span><br></pre></td></tr></table></figure>
<ul>
<li>首先尝试把镜像下载下来，需要科学上网</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubeadm config images pull</span><br></pre></td></tr></table></figure>
<ul>
<li>初始化 kubeadm</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubeadm init --kubernetes-version=v1.14.0 --pod-network-cidr=10.244.0.0/16 --service-cidr=10.96.0.0/12 --ignore-preflight-errors=Swap</span><br></pre></td></tr></table></figure>
<ul>
<li>如果报错可以使用下面命令查看</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">journalctl -xeu kubelet</span><br></pre></td></tr></table></figure>
<ul>
<li>如果过程出错而中断，可以使用下面命令来清理环境，重新初始化</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubeadm reset</span><br></pre></td></tr></table></figure>
<ul>
<li>初始化过程可以查看</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node1 ~]<span class="comment"># docker image ls</span></span><br><span class="line">REPOSITORY                           TAG        IMAGE ID        CREATED          SIZE</span><br><span class="line">k8s.gcr.io/kube-proxy                v1.14.0    5cd54e388aba    2 days ago       82.1MB</span><br><span class="line">k8s.gcr.io/kube-apiserver            v1.14.0    ecf910f40d6e    2 days ago       210MB</span><br><span class="line">k8s.gcr.io/kube-controller-manager   v1.14.0    b95b1efa0436    2 days ago       158MB</span><br><span class="line">k8s.gcr.io/kube-scheduler            v1.14.0    00638a24688b    2 days ago       81.6MB</span><br><span class="line">k8s.gcr.io/coredns                   1.3.1      eb516548c180    2 months ago     40.3MB</span><br><span class="line">k8s.gcr.io/etcd                      3.3.10     2c4adeb21b4f    3 months ago     258MB</span><br><span class="line">k8s.gcr.io/pause                     3.1        da86e6ba6ca1    15 months ago    742kB</span><br></pre></td></tr></table></figure>
<ul>
<li>出现错误可能需要关闭 swap</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 关闭Swap，机器重启后不生效</span></span><br><span class="line">swapoff -a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改/etc/fstab永久关闭Swap</span></span><br><span class="line">cp -p /etc/fstab /etc/fstab.bak$(date <span class="string">'+%Y%m%d%H%M%S'</span>)</span><br><span class="line"><span class="comment"># Redhat</span></span><br><span class="line">sed -i <span class="string">"s/\/dev\/mapper\/rhel-swap/\#\/dev\/mapper\/rhel-swap/g"</span> /etc/fstab</span><br><span class="line"><span class="comment"># CentOS</span></span><br><span class="line">sed -i <span class="string">"s/\/dev\/mapper\/centos-swap/\#\/dev\/mapper\/centos-swap/g"</span> /etc/fstab</span><br><span class="line"><span class="comment"># 修改后重新挂载全部挂载点</span></span><br><span class="line">mount -a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看Swap</span></span><br><span class="line">free -m</span><br><span class="line">cat /proc/swaps</span><br></pre></td></tr></table></figure>
<ul>
<li>最后执行成功，保存这个执行结果</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Your Kubernetes master has initialized successfully!</span><br><span class="line">您的 Kubernetes Master 已成功初始化！</span><br><span class="line"></span><br><span class="line">To start using your cluster, you need to run the following as a regular user:</span><br><span class="line">要开始使用群集，您需要以普通用户身份运行以下命令：</span><br><span class="line"></span><br><span class="line">  mkdir -p <span class="variable">$HOME</span>/.kube</span><br><span class="line">  sudo cp -i /etc/kubernetes/admin.conf <span class="variable">$HOME</span>/.kube/config</span><br><span class="line">  sudo chown $(id -u):$(id -g) <span class="variable">$HOME</span>/.kube/config</span><br><span class="line"></span><br><span class="line">You should now deploy a pod network to the cluster.</span><br><span class="line">您现在应该将 pod 网络部署到群集。</span><br><span class="line"></span><br><span class="line">Run <span class="string">"kubectl apply -f [podnetwork].yaml"</span> with one of the options listed at:</span><br><span class="line">使用以下列出的选项之一运行 <span class="string">"kubectl apply -f [podnetwork] .yaml"</span></span><br><span class="line"></span><br><span class="line">  https://kubernetes.io/docs/concepts/cluster-administration/addons/</span><br><span class="line"></span><br><span class="line">You can now join any number of machines by running the following on each node</span><br><span class="line">as root:</span><br><span class="line">您现在可以在每个节点上以 root 身份运行以下命令来加入任意数量的计算机：</span><br><span class="line"></span><br><span class="line">  kubeadm join 172.16.100.101:6443 --token ygve26.fwxm6lsynrtyv7lp --discovery-token-ca-cert-hash sha256:3b24af40a5039253670f1cb3af68431de3716f85bd17159f87b6910e41980d27</span><br></pre></td></tr></table></figure>
<ul>
<li>以普通用户身份运行以下命令，在这我用 root</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir -p <span class="variable">$HOME</span>/.kube</span><br><span class="line">sudo cp -i /etc/kubernetes/admin.conf <span class="variable">$HOME</span>/.kube/config</span><br><span class="line">sudo chown $(id -u):$(id -g) <span class="variable">$HOME</span>/.kube/config</span><br></pre></td></tr></table></figure>
<h3 id="部署-flannel"><a href="#部署-flannel" class="headerlink" title="部署 flannel"></a>部署 flannel</h3><ul>
<li>部署 flannel</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml</span><br></pre></td></tr></table></figure>
<ul>
<li>查看 Master 应该处于 Ready 状态</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get cs                    <span class="comment"># 查看集群信息</span></span><br><span class="line">kubectl get nodes                 <span class="comment"># 查看节点信息</span></span><br></pre></td></tr></table></figure>
<ul>
<li>查看 kube-system 名称空间的 pods ，都处于 Runing 就好</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get pods -n kube-system</span><br><span class="line">kubectl get ns                    <span class="comment"># 查看目前有什么名称空间</span></span><br></pre></td></tr></table></figure>
<h3 id="设置开机启动"><a href="#设置开机启动" class="headerlink" title="设置开机启动"></a>设置开机启动</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> docker</span><br><span class="line">systemctl <span class="built_in">enable</span> kubelet</span><br></pre></td></tr></table></figure>
<h2 id="安装-node"><a href="#安装-node" class="headerlink" title="安装 node"></a>安装 node</h2><ul>
<li>配置 kuberetes 安装源</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat &gt;&gt;/etc/yum.repos.d/kuberetes.repo&lt;&lt;EOF</span><br><span class="line">[kuberneres]</span><br><span class="line">name=Kubernetes</span><br><span class="line">baseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64/</span><br><span class="line">gpgcheck=0</span><br><span class="line">gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg</span><br><span class="line">enabled=1</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>
<ul>
<li>配置 docker 安装源</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -o /etc/yum.repos.d/docker-ce.repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure>
<ul>
<li>在 master 和 node 节点安装</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install docker-ce kubelet kubeadm kubectl</span><br></pre></td></tr></table></figure>
<ul>
<li>编辑docker，设置Docker下载镜像时候使用代理</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /usr/lib/systemd/system/docker.service</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[Service]</span><br><span class="line">Environment=&quot;HTTPS_PROXY=127.0.0.1:9666&quot;</span><br><span class="line">Environment=&quot;NO_PROXY=127.0.0.0/8,172.16.0.0/16&quot;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl daemon-reload</span><br></pre></td></tr></table></figure>
<ul>
<li>确保如下两个内核功能为开启状态，应该添加到 sysctl.conf ，否则 POD 访问可能会出现问题</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat /proc/sys/net/bridge/bridge-nf-call-ip6tables</span><br><span class="line">cat /proc/sys/net/bridge/bridge-nf-call-iptables</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat &gt;&gt;/etc/sysctl.conf&lt;&lt;EOF</span><br><span class="line">net.bridge.bridge-nf-call-ip6tables = 1</span><br><span class="line">net.bridge.bridge-nf-call-iptables = 1</span><br><span class="line">net.ipv4.ip_forward = 1</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>
<ul>
<li>设置开机启动 kubelet</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> kubelet</span><br><span class="line">systemctl <span class="built_in">enable</span> docker</span><br><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure>
<ul>
<li>关闭 swap 的警告</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/sysconfig/kubelet</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">KUBELET_EXTRA_ARGS=<span class="string">"--fail-swap-on=false"</span></span><br></pre></td></tr></table></figure>
<ul>
<li>加入 Matser 刚创建的集群，即 Matser 初始化成功的提示信息内的代码，再加上：<code>--ignore-preflight-errors=Swap</code></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubeadm join 172.16.100.101:6443 --token 2yamq7.x590aiatbt3qy9o6 --discovery-token-ca-cert-hash sha256:afcbe82d3720418d02f54e8cc19052bff17fe2374c35865c0f4b079d08c98790 --ignore-preflight-errors=Swap</span><br></pre></td></tr></table></figure>
<ul>
<li>执行的结果</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">This node has joined the cluster:</span><br><span class="line">此节点已加入群集：</span><br><span class="line">* Certificate signing request was sent to master and a response was received.</span><br><span class="line">证书签名请求已发送给 Master ，并收到了回复。</span><br><span class="line"></span><br><span class="line">* The Kubelet was informed of the new secure connection details.</span><br><span class="line">Kubelet 被告知新的安全连接细节。</span><br><span class="line"></span><br><span class="line">Run <span class="string">'kubectl get nodes'</span> on the master to see this node join the cluster.</span><br><span class="line">在主服务器上运行 <span class="string">'kubectl get nodes'</span> 以查看此节点是否加入群集。</span><br></pre></td></tr></table></figure>
<ul>
<li>加入成功后 Master 会要求该节点下载相关的 docker 镜像运行，应该保持科学上网，一般需要下载3个。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker image ls    <span class="comment"># 查看包的下载进度</span></span><br><span class="line">kubectl get nodes  <span class="comment"># 在 Master 查看 node 节点是否准备好</span></span><br></pre></td></tr></table></figure>
<ul>
<li>在 Matser 节点运行指令，可以看到 kube-proxy 和 kube-flannel 在 Matser 和 node 节点都运行了</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get pods -n kube-system -o wide</span><br></pre></td></tr></table></figure>
<ul>
<li>node 节点需要翻墙下载镜像太慢，建议使用 docker 镜像的导入导出功能</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker image save -o /tmp/kube-proxy.tar k8s.gcr.io/kube-proxy</span><br><span class="line">docker image save -o /tmp/flannel.tar quay.io/coreos/flannel</span><br><span class="line">docker image save -o /tmp/pause.tar k8s.gcr.io/pause</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker image load -i /tmp/kube-proxy.tar</span><br><span class="line">docker image load -i /tmp/pause.tar</span><br><span class="line">docker image load -i /tmp/flannel.tar</span><br></pre></td></tr></table></figure>
<h2 id="kubectl"><a href="#kubectl" class="headerlink" title="kubectl"></a>kubectl</h2><p>kubectl 是 apiserver 的客户端程序，这个客户端程序是通过连接 master 节点上的 apiserver ，实现各种 k8s 对象的增删改查等基本操作，在 k8s 可被管理的对象有很多个</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">基本命令 (初级):</span><br><span class="line">  create         从文件或标准输入创建资源</span><br><span class="line">  expose         获取一个复制控制器，服务，部署或者暴露一个 POD 将其作为新的 Kubernetes 服务公开</span><br><span class="line">  run            创建并运行特定的镜像，创建使用 deployment 或 job 管理的容器</span><br><span class="line">  <span class="built_in">set</span>            设置对象的特定功能</span><br><span class="line"></span><br><span class="line">基本命令 (中级):</span><br><span class="line">  explain        文档或者资源</span><br><span class="line">  get            显示一个或多个资源</span><br><span class="line">  edit           编辑服务器上的资源</span><br><span class="line">  delete         按文件名，标准输入，资源和名称或资源和标签选择器删除资源</span><br><span class="line"></span><br><span class="line">部署命令:</span><br><span class="line">  rollout        管理资源的部署</span><br><span class="line">  scale          为部署设置新大小，ReplicaSet, Replication Controller, Job</span><br><span class="line">  autoscale      自动扩展一个部署, ReplicaSet, 或者 ReplicationController</span><br><span class="line"></span><br><span class="line">群集管理命令:</span><br><span class="line">  certificate    修改证书资源.</span><br><span class="line">  cluster-info   显示群集信息</span><br><span class="line">  top            显示资源（CPU /内存/存储）使用情况。</span><br><span class="line">  cordon         将节点标记为不可调度</span><br><span class="line">  uncordon       将节点标记为可调度</span><br><span class="line">  drain          设定 node 进入维护模式</span><br><span class="line">  taint          更新一个或多个节点上的污点</span><br><span class="line"></span><br><span class="line">故障排除和调试命令:</span><br><span class="line">  describe       显示特定资源或资源组的详细信息</span><br><span class="line">  logs           在容器中打印容器的日志</span><br><span class="line">  attach         附加到正在运行的容器</span><br><span class="line">  <span class="built_in">exec</span>           在容器中执行命令</span><br><span class="line">  port-forward   将一个或多个本地端口转发到 pod</span><br><span class="line">  proxy          运行代理到 Kubernetes API 服务器</span><br><span class="line">  cp             将文件和目录复制到容器，和从容器复制，跨容器复制文件</span><br><span class="line">  auth           检查授权</span><br><span class="line"></span><br><span class="line">高级命令:</span><br><span class="line">  diff           针对将要应用的版本的 Diff 实时版本</span><br><span class="line">  apply          通过文件名或标准输入将配置应用于资源</span><br><span class="line">  patch          使用策略合并补丁更新资源的字段</span><br><span class="line">  replace        用文件名或标准输入替换资源</span><br><span class="line">  <span class="built_in">wait</span>           实验阶段命令：在一个或多个资源上等待特定条件，定义一个触发器</span><br><span class="line">  convert        在不同的API版本之间转换配置文件</span><br><span class="line">  kustomize      从目录或远程 URL 构建 kustomization 目标</span><br><span class="line"></span><br><span class="line">设置命令:</span><br><span class="line">  label          更新资源上的标签</span><br><span class="line">  annotate       更新资源上的注释</span><br><span class="line">  completion     命令补全相关功能</span><br><span class="line"></span><br><span class="line">其他命令:</span><br><span class="line">  api-resources  在服务器上打印支持的API资源</span><br><span class="line">  api-versions   以 <span class="string">"group/version"</span> 的形式在服务器上打印支持的API版本</span><br><span class="line">  config         修改 kubeconfig 文件</span><br><span class="line">  plugin         提供与插件交互的实用程序</span><br><span class="line">  version        打印客户端和服务器版本信息</span><br></pre></td></tr></table></figure>
<h1 id="入门命令"><a href="#入门命令" class="headerlink" title="入门命令"></a>入门命令</h1><h2 id="run"><a href="#run" class="headerlink" title="run"></a>run</h2><ul>
<li>创建控制器并运行镜像</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl run nginx --image=nginx:latest    <span class="comment"># 创建一个名为 nginx 的控制器，运行 nginx:latest 版本的镜像</span></span><br></pre></td></tr></table></figure>
<ul>
<li>指定运行的 POD 数量</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl run nginx --image=nginx --replicas=5  <span class="comment"># 启动 5 个 POD</span></span><br></pre></td></tr></table></figure>
<ul>
<li>不运行容器的默认命令，使用自定义的指令</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl run nginx --image=nginx --<span class="built_in">command</span> -- &lt;cmd&gt; &lt;arg1&gt; ... &lt;argN&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>运行一个周期任务</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl run pi --schedule=<span class="string">"0/5 * * * ?"</span> --image=perl --restart=OnFailure -- perl -Mbignum=bpi -wle <span class="string">'print bpi(2000)'</span></span><br></pre></td></tr></table></figure>
<h2 id="run示例"><a href="#run示例" class="headerlink" title="run示例"></a>run示例</h2><ul>
<li>指定控制器名称运行 nginx 指定端口和副本数量，以测试模式运行</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl run nginx-deploy --image=nginx --port=80 --replicas=1 --dry-run=<span class="literal">true</span></span><br></pre></td></tr></table></figure>
<ul>
<li>查看容器是否运行</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get deployment</span><br></pre></td></tr></table></figure>
<ul>
<li>查看被调度的主机</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get pod -o wide</span><br></pre></td></tr></table></figure>
<ul>
<li>通过 ip 地址直接访问，由于所有的 POD 处于同一个网络中，所以在集群内部是可以访问的</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl 10.244.2.2</span><br></pre></td></tr></table></figure>
<ul>
<li>假如现在删除刚创建的这个 POD，那么副本控制器会自动在其他的 node 上重建这个 POD</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl delete pods nginx-deploy-5c9b546997-jsmk6</span><br></pre></td></tr></table></figure>
<ul>
<li>再次执行查看，会发现容器已经被调度到其他节点上运行了</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get pod -o wide</span><br></pre></td></tr></table></figure>
<h2 id="expose"><a href="#expose" class="headerlink" title="expose"></a>expose</h2><p>现在存在一个问题，就是 POD 的 IP 地址可能随时发生变动，所以不能作为访问的入口，那么就需要 service 来代理 POD 来创建一个固定的端点。</p>
<ul>
<li>创建一个 service 暴露一个服务</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl expose deployment nginx-deploy --name=nginx --port=80 --target-port=80 --protocol=TCP</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">在控制器 nginx-deploy 上创建名字为 nginx 的 service ，它工作端口为 80，代理的后端容器端口 80，协议为 TCP。</span><br></pre></td></tr></table></figure>
<ul>
<li>可以看到刚刚创建的名字为 nginx 的 service ，现在就可以在集群内用 service 的地址来访问了，外部不行</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get service</span><br></pre></td></tr></table></figure>
<ul>
<li>删除一个任务</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl delete deployment nginx-deploy</span><br></pre></td></tr></table></figure>
<h2 id="coredns"><a href="#coredns" class="headerlink" title="coredns"></a>coredns</h2><p>service 提供了对 pod 的固定访问端点，但是 service 本身的变动我们无法知晓，需要 coredns 对 service 做域名解析。</p>
<ul>
<li>查看 coredns 运行状态</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get pods -n kube-system -o wide</span><br></pre></td></tr></table></figure>
<ul>
<li>查看各个 kube-system 命名空间运行的服务，可以看到 kube-dns 运行的 IP 地址</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get service -n kube-system</span><br></pre></td></tr></table></figure>
<ul>
<li>使用 kube-dns 来解析 nginx 这个 service 的地址就可以正常解析了</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dig -t A nginx.default.svc.cluster.local @10.96.0.10</span><br></pre></td></tr></table></figure>
<ul>
<li>创建一个访问 nginx 客户端容器，并进入交互式模式，这个容器默认的 dns 服务器就是 kube-dns 所在的服务器</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl run client --image=busybox --replicas=1 -it --restart=Never</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/ <span class="comment"># cat /etc/resolv.conf </span></span><br><span class="line">nameserver 10.96.0.10                                               <span class="comment"># kube-dns 地址</span></span><br><span class="line">search default.svc.cluster.local svc.cluster.local cluster.local    <span class="comment"># 默认的解析搜索域</span></span><br><span class="line">options ndots:5</span><br></pre></td></tr></table></figure>
<ul>
<li>在 busybox 这个容器中请求 nginx 这个域名的 service ，能够正常访问</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget -O - -q http://nginx:80/</span><br></pre></td></tr></table></figure>
<h3 id="模拟-POD-被删除"><a href="#模拟-POD-被删除" class="headerlink" title="模拟 POD 被删除"></a>模拟 POD 被删除</h3><ul>
<li>现在我们删除 service 后端的 POD ，副本控制器会自动创建新的 POD，而 service 则会自动指向新创建的 POD</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl delete pods nginx-deploy-5c9b546997-4w24n</span><br></pre></td></tr></table></figure>
<ul>
<li>查看由副本控制器自动创建的 POD</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get pods</span><br></pre></td></tr></table></figure>
<ul>
<li>在 busybox 这个容器中请求 nginx 这个域名的 service ，访问没有受到影响</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget -O - -q http://nginx:80/</span><br></pre></td></tr></table></figure>
<h3 id="模拟-service-被删除"><a href="#模拟-service-被删除" class="headerlink" title="模拟 service 被删除"></a>模拟 service 被删除</h3><ul>
<li>当我们删除 service 并且重新建立一个 service 再次查看 service 的地址已经发生变化了</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl delete service nginx</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl expose deployment nginx-deploy --name=nginx --port=80 --target-port=80 --protocol=TCP</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get service</span><br></pre></td></tr></table></figure>
<ul>
<li>在 busybox 这个容器中请求 nginx 这个域名的 service ，访问没有仍然没有受到影响</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget -O - -q http://nginx:80/</span><br></pre></td></tr></table></figure>
<h2 id="labels"><a href="#labels" class="headerlink" title="labels"></a>labels</h2><p>为什么 Pod 被删除后，servic 仍然能够正确的调度到新的 POD 上，这就是 k8s 的 labels 这个机制来保证的。</p>
<p>能够使用标签机制不止有 pod、在 k8s 中很多对象都可以使用标签，例如：node、service</p>
<ul>
<li>查看 service 的详细信息，会发现标签选择器</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl describe service nginx</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Name:              nginx</span><br><span class="line">Namespace:         default</span><br><span class="line">Labels:            run=nginx-deploy</span><br><span class="line">Annotations:       &lt;none&gt;</span><br><span class="line">Selector:          run=nginx-deploy       <span class="comment"># 这个选择器会自动选中 run 标签，且值为 nginx-deploy 的 POD</span></span><br><span class="line">Type:              ClusterIP</span><br><span class="line">IP:                10.101.149.4</span><br><span class="line">Port:              &lt;<span class="built_in">unset</span>&gt;  80/TCP</span><br><span class="line">TargetPort:        80/TCP</span><br><span class="line">Endpoints:         10.244.2.4:80          <span class="comment"># 当 service 的后端，当 POD 发生变动则立即会更新</span></span><br><span class="line">Session Affinity:  None</span><br><span class="line">Events:            &lt;none&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>查看 POD 的标签，会看到拥有 run=nginx-deploy 标签的容器，而人为删除一个 POD 后，副本控制器创建的副本上的标签不会变化，所以标签又被 service 关联。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get pods --show-labels</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">NAME                            READY   STATUS    RESTARTS   AGE     LABELS</span><br><span class="line">client                          1/1     Running   0          21m     run=client</span><br><span class="line">nginx-deploy-5c9b546997-kh88w   1/1     Running   0          8m37s   pod-template-hash=5c9b546997,run=nginx-deploy</span><br></pre></td></tr></table></figure>
<ul>
<li>查看 POD 的详细信息，也可以查看到 POD 的详细信息</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl describe deployment nginx-deploy</span><br></pre></td></tr></table></figure>
<ul>
<li>根据标签过滤，使用 -l 来指定标签名称或同时过滤其值</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get pods --show-labels -l run=nginx-deploy</span><br></pre></td></tr></table></figure>
<ul>
<li>标签选择器集中运算</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">关系与：KEY,KEY、KEY=VALUE2,KEY=VALUE2       <span class="comment"># -l run,app</span></span><br><span class="line">等值关系：KEY = VALUE、KEY != VALUE           <span class="comment"># -l run=nginx-deploy,app!=myapp</span></span><br><span class="line">集合关系：KYE <span class="keyword">in</span>|not <span class="keyword">in</span> (VALUE1,VALUE2)      <span class="comment"># -l "release in (canary,bata,alpha)"</span></span><br></pre></td></tr></table></figure>
<ul>
<li>显示指定的标签的值，下面显示了两个标签</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get pods --show-labels -L run,pod-template-hash</span><br></pre></td></tr></table></figure>
<ul>
<li>为指定的 POD 打标签，为 client 这个 POD 打上一个 release 标签，其值为 canary</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl label pods client release=canary</span><br></pre></td></tr></table></figure>
<ul>
<li>修改 POD 的标签，使用 –overwrite 进行修改原有标签</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl label pods client release=stable --overwrite</span><br></pre></td></tr></table></figure>
<ul>
<li>删除指定的 nodes 上的标签，使用标签名称加 - 符号</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl label nodes node2 disktype-</span><br></pre></td></tr></table></figure>
<ul>
<li>许多资源支持内嵌字段来定义其使用的标签选择器，例如 service 关联 pod 时候：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">matchLabels：直接给定键值</span><br><span class="line">matchExpressions：基于给定的表达式来定义使用标签选择器：&#123;key:<span class="string">"KEY"</span>,operator:<span class="string">"OPERATOR"</span>,value:[VAL1,VAL2,...]&#125;</span><br><span class="line">    使用 key 与 value 进行 operator 运算，复合条件的才被选择</span><br><span class="line">    操作符：</span><br><span class="line">    	In、NotIn：其 value 列表必须有值</span><br><span class="line">    	Exists、NotExists：其 value 必须为空</span><br></pre></td></tr></table></figure>
<ul>
<li>k8s 中很多对象都可以打标签，例如给 nodes 打一个标记，随后在添加资源时候就可以让资源对节点有倾向性了</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl label nodes node2 disktype=ssd</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get nodes --show-labels</span><br></pre></td></tr></table></figure>
<h2 id="动态扩容"><a href="#动态扩容" class="headerlink" title="动态扩容"></a>动态扩容</h2><ul>
<li>扩容一个集群的的 POD，下面命令表示修改 deployment 控制器下的 nginx-deply 容器的副本数量为2</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl scale --replicas=5 deployment nginx-deploy</span><br></pre></td></tr></table></figure>
<h2 id="滚动升级"><a href="#滚动升级" class="headerlink" title="滚动升级"></a>滚动升级</h2><ul>
<li>更换 nginx-deploy 这个控制器下的 nginx-deploy 容器镜像为 ikubernetes/myapp:v2</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl <span class="built_in">set</span> image deployment nginx-deploy nginx-deploy=ikubernetes/myapp:v2</span><br></pre></td></tr></table></figure>
<ul>
<li>查看更新的过程，直到 5 个容器中运行的镜像全部更新完毕</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl rollout status deployment nginx-deploy</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node1 ~]<span class="comment"># kubectl rollout status deployment nginx-deploy</span></span><br><span class="line">Waiting <span class="keyword">for</span> deployment <span class="string">"nginx-deploy"</span> rollout to finish: 3 out of 5 new replicas have been updated...</span><br><span class="line">Waiting <span class="keyword">for</span> deployment <span class="string">"nginx-deploy"</span> rollout to finish: 3 out of 5 new replicas have been updated...</span><br><span class="line">Waiting <span class="keyword">for</span> deployment <span class="string">"nginx-deploy"</span> rollout to finish: 3 out of 5 new replicas have been updated...</span><br><span class="line">Waiting <span class="keyword">for</span> deployment <span class="string">"nginx-deploy"</span> rollout to finish: 3 out of 5 new replicas have been updated...</span><br><span class="line">Waiting <span class="keyword">for</span> deployment <span class="string">"nginx-deploy"</span> rollout to finish: 3 out of 5 new replicas have been updated...</span><br><span class="line">Waiting <span class="keyword">for</span> deployment <span class="string">"nginx-deploy"</span> rollout to finish: 4 out of 5 new replicas have been updated...</span><br><span class="line">Waiting <span class="keyword">for</span> deployment <span class="string">"nginx-deploy"</span> rollout to finish: 4 out of 5 new replicas have been updated...</span><br><span class="line">Waiting <span class="keyword">for</span> deployment <span class="string">"nginx-deploy"</span> rollout to finish: 4 out of 5 new replicas have been updated...</span><br><span class="line">Waiting <span class="keyword">for</span> deployment <span class="string">"nginx-deploy"</span> rollout to finish: 4 out of 5 new replicas have been updated...</span><br><span class="line">Waiting <span class="keyword">for</span> deployment <span class="string">"nginx-deploy"</span> rollout to finish: 4 out of 5 new replicas have been updated...</span><br><span class="line">Waiting <span class="keyword">for</span> deployment <span class="string">"nginx-deploy"</span> rollout to finish: 2 old replicas are pending termination...</span><br><span class="line">Waiting <span class="keyword">for</span> deployment <span class="string">"nginx-deploy"</span> rollout to finish: 2 old replicas are pending termination...</span><br><span class="line">Waiting <span class="keyword">for</span> deployment <span class="string">"nginx-deploy"</span> rollout to finish: 2 old replicas are pending termination...</span><br><span class="line">Waiting <span class="keyword">for</span> deployment <span class="string">"nginx-deploy"</span> rollout to finish: 1 old replicas are pending termination...</span><br><span class="line">Waiting <span class="keyword">for</span> deployment <span class="string">"nginx-deploy"</span> rollout to finish: 1 old replicas are pending termination...</span><br><span class="line">Waiting <span class="keyword">for</span> deployment <span class="string">"nginx-deploy"</span> rollout to finish: 1 old replicas are pending termination...</span><br><span class="line">Waiting <span class="keyword">for</span> deployment <span class="string">"nginx-deploy"</span> rollout to finish: 4 of 5 updated replicas are available...</span><br><span class="line">deployment <span class="string">"nginx-deploy"</span> successfully rolled out</span><br></pre></td></tr></table></figure>
<ul>
<li>回滚操作，不指定任何的镜像则为上一个版本的镜像</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl rollout undo deployment nginx-deploy</span><br></pre></td></tr></table></figure>
<blockquote>
<p>  如果防止更新过程中被调度，那么就需要学习就绪性检测才能实现</p>
</blockquote>
<h2 id="集群外访问"><a href="#集群外访问" class="headerlink" title="集群外访问"></a>集群外访问</h2><ul>
<li>修改 service 的网络类型为 NodePort</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl edit service nginx</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">type</span>: ClusterIP -&gt; <span class="built_in">type</span>: NodePort</span><br></pre></td></tr></table></figure>
<ul>
<li>查看 service 的信息，发现多了一个 30982 端口</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get service</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">NAME         TYPE        CLUSTER-IP     EXTERNAL-IP   PORT(S)        AGE</span><br><span class="line">kubernetes   ClusterIP   10.96.0.1      &lt;none&gt;        443/TCP        15h</span><br><span class="line">nginx        NodePort    10.105.27.11   &lt;none&gt;        80:30982/TCP   42m</span><br></pre></td></tr></table></figure>
<ul>
<li>在集群外部使用任意的 node IP 地址 + 端口来访问</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">http://172.16.100.101:30982/</span><br></pre></td></tr></table></figure>
<h2 id="排查日志"><a href="#排查日志" class="headerlink" title="排查日志"></a>排查日志</h2><ul>
<li>查看一个 pod 的某个容器的运行日志</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl logs pod-demo busybox</span><br></pre></td></tr></table></figure>
<h2 id="连入-POD-容器"><a href="#连入-POD-容器" class="headerlink" title="连入 POD 容器"></a>连入 POD 容器</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl <span class="built_in">exec</span> -it pod-demo -c myapp -- /bin/sh</span><br></pre></td></tr></table></figure>
<h1 id="配置清单使用"><a href="#配置清单使用" class="headerlink" title="配置清单使用"></a>配置清单使用</h1><p>apiserver 仅接收 json 格式的资源定义，yaml 格式定义提供的配置清单，apiserver 可自动将其转换为 json 格式，而后再进行执行。</p>
<h2 id="可配置的对象"><a href="#可配置的对象" class="headerlink" title="可配置的对象"></a>可配置的对象</h2><ul>
<li>可用资源清单配置的对象</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">workload：Pod、ReplicaSet、Deployment、StatefulSet、DaemonSet、Job、CronJob</span><br><span class="line">服务发现及均衡：Service、Ingress</span><br><span class="line">配置与存储：Volume、CSI</span><br><span class="line">    ConfigMap、Secret</span><br><span class="line">    DownwardAPI</span><br><span class="line">集群级资源</span><br><span class="line">    Namespace、None、Role、ClusterRole、RoleBinding、ClusterRoleBinding</span><br><span class="line">元数据类型资源</span><br><span class="line">    HPA、PodTemplate、LimitRange</span><br></pre></td></tr></table></figure>
<h2 id="配置清单组成"><a href="#配置清单组成" class="headerlink" title="配置清单组成"></a>配置清单组成</h2><ul>
<li>配置清单组成部分，大部分资源使用配置清单方式来创建</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion</span><br><span class="line">	<span class="comment"># 以 "group/version" 形式指明，这个对象属于哪个 API 组（版本）</span></span><br><span class="line">kind:</span><br><span class="line">    <span class="comment"># 资源类别，标记创建什么类型的资源</span></span><br><span class="line">metadata:</span><br><span class="line">	<span class="comment"># 元数据内部是嵌套的字段</span></span><br><span class="line">	<span class="comment"># 定义了资源对象的名称、命名空间（k8s级别的不是系统的）等、标签、注解等</span></span><br><span class="line">spec:</span><br><span class="line">	<span class="comment"># 规范定义资源应该拥有什么样的特性，依靠控制器确保特性能够被满足</span></span><br><span class="line">	<span class="comment"># 它是用户定义的所期望了资源状态</span></span><br><span class="line">status:</span><br><span class="line">	<span class="comment"># 显示资源的当前状态，k8s 就是确保当前状态向目标状态无限靠近从而满足用户期望</span></span><br><span class="line">	<span class="comment"># 它是只读的，代表了资源当前状态</span></span><br></pre></td></tr></table></figure>
<ul>
<li>获取全部的 api 版本</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl api-versions</span><br></pre></td></tr></table></figure>
<h2 id="获取清单帮助"><a href="#获取清单帮助" class="headerlink" title="获取清单帮助"></a>获取清单帮助</h2><ul>
<li>查看 k8s 某个内置对象的配置清单格式，应该包含哪些字段，使用 . 来显示字段的格式帮助信息</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl explain pods</span><br><span class="line">kubectl explain pods.metadata</span><br></pre></td></tr></table></figure>
<h2 id="清单基本格式"><a href="#清单基本格式" class="headerlink" title="清单基本格式"></a>清单基本格式</h2><ul>
<li>定义一个资源清单</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: pod-deme</span><br><span class="line">  namespace: default</span><br><span class="line">  labels:</span><br><span class="line">    app: myapp</span><br><span class="line">    tier: frontend</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: myapp</span><br><span class="line">    image: ikubernetes/myapp:v1</span><br><span class="line">  - name: busybox</span><br><span class="line">    image: busybox:latest</span><br><span class="line">    <span class="built_in">command</span>:</span><br><span class="line">    - <span class="string">"/bin/sh"</span></span><br><span class="line">    - <span class="string">"-c"</span></span><br><span class="line">    - <span class="string">"sleep 10"</span></span><br></pre></td></tr></table></figure>
<h2 id="快捷获取清单"><a href="#快捷获取清单" class="headerlink" title="快捷获取清单"></a>快捷获取清单</h2><ul>
<li>使用 -o 参数来指定对象数据的输出格式，使用 –dry-run 来测试性执行一个指令，它两个结合起来，就可以通过命令创建，且生成 yaml 格式配置文件了 -o yaml –dry-run</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl create secret docker-registry regsecret --docker-server=registry-vpc.cn-hangzhou.aliyuncs.com --docker-username=admin --docker-password=123456 --docker-email=420123641@qq.com -o yaml --dry-run</span><br></pre></td></tr></table></figure>
<h2 id="create-创建"><a href="#create-创建" class="headerlink" title="create 创建"></a>create 创建</h2><ul>
<li>创建资源清单中的资源，这样创建的为裸 POD ，没有控制器管理，所以删除后不会自动重建</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl create -f pod-demo.yaml</span><br></pre></td></tr></table></figure>
<h2 id="delete-删除"><a href="#delete-删除" class="headerlink" title="delete 删除"></a>delete 删除</h2><ul>
<li>删除资源清单中定义的 POD</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl delete -f pod-demo.yaml</span><br></pre></td></tr></table></figure>
<h2 id="applay-创建或更新"><a href="#applay-创建或更新" class="headerlink" title="applay 创建或更新"></a>applay 创建或更新</h2><p>applay 可以执行多次，如果发现文件不同，则更新</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl applay -f pod-demo.yaml</span><br></pre></td></tr></table></figure>
<h1 id="POD-配置清单"><a href="#POD-配置清单" class="headerlink" title="POD 配置清单"></a>POD 配置清单</h1><h2 id="pods-metadata-POD元数据"><a href="#pods-metadata-POD元数据" class="headerlink" title="pods.metadata POD元数据"></a>pods.metadata POD元数据</h2><h3 id="labels-标签"><a href="#labels-标签" class="headerlink" title="labels 标签"></a>labels 标签</h3><ul>
<li>labels 定义标签，键值对组成的标签</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">labels:</span><br><span class="line">  app: myapp</span><br><span class="line">  tier: frontend</span><br></pre></td></tr></table></figure>
<h2 id="pods-spec-规范"><a href="#pods-spec-规范" class="headerlink" title="pods.spec 规范"></a>pods.spec 规范</h2><p>nodeName 运行节点</p>
<ul>
<li>在使用资源清单定义 pod 时候，使用 nodeName 可以直接绑定资源对象在哪个 POD 运行的节点</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">pod-deme</span></span><br><span class="line"><span class="attr">  namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">  labels:</span></span><br><span class="line"><span class="attr">    app:</span> <span class="string">myapp</span></span><br><span class="line"><span class="attr">    tier:</span> <span class="string">frontend</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  nodeName:</span> <span class="string">node2</span>                           <span class="comment"># 直接指定 POD 运行的节点</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">myapp</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">ikubernetes/myapp:v1</span></span><br><span class="line"><span class="attr">    imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br></pre></td></tr></table></figure>
<h3 id="nodeSelector-节点选择"><a href="#nodeSelector-节点选择" class="headerlink" title="nodeSelector 节点选择"></a>nodeSelector 节点选择</h3><ul>
<li>在使用资源清单定义 pod 时候，使用 nodeSelector （节点标签选择器）字段，来定义节点的倾向性</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">pod-deme</span></span><br><span class="line"><span class="attr">  namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">  labels:</span></span><br><span class="line"><span class="attr">    app:</span> <span class="string">myapp</span></span><br><span class="line"><span class="attr">    tier:</span> <span class="string">frontend</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  nodeSelector:</span>                            <span class="comment"># 在 spec 中定义这个 POD 的节点倾向性</span></span><br><span class="line">  	<span class="attr">disktype:</span> <span class="string">ssd</span>                         <span class="comment"># 这个 POD 最终会运行在拥有 disktype 标签且值为 ssd 的 nodes 上</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">myapp</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">ikubernetes/myapp:v1</span></span><br><span class="line"><span class="attr">    imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line"><span class="attr">    ports:</span></span><br></pre></td></tr></table></figure>
<ul>
<li>从文件启动 pod，观察 pod 运行的节点，会发现已经运行在有标签的 node 节点上了</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl create -f pod-demo.yaml</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl get pods -o wide</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">NAME       READY   STATUS    RESTARTS   AGE   IP            NODE    NOMINATED NODE   READINESS GATES</span><br><span class="line">pod-demo   1/1     Running   0          21s   10.244.2.29   node3   &lt;none&gt;           &lt;none&gt;</span><br></pre></td></tr></table></figure>
<h3 id="restartPolicy-POD重启策略"><a href="#restartPolicy-POD重启策略" class="headerlink" title="restartPolicy POD重启策略"></a>restartPolicy POD重启策略</h3><p>Always：一旦容器挂了，那么总是重启它，k8s 每次重启策略为 30 秒的两倍，直到等待 300 秒重启。</p>
<p>OnFailure：只有其状态为错误的时候才去重启它</p>
<p>Never：从来不重启，挂了就挂了</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">一旦某个 POD 被调度到某个节点上，只要这个节点在，那么它就不会被重新调度，只能被重启，除非 POD 被删除才会被重新调度，或者 node 挂了，才会被重新调度，否则只要 node 在，那么 POD 就不会被重新调度，如果 POD 启动失败，那么将不断的重启 POD。</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">当需要终止 POD ，k8s 发送 <span class="built_in">kill</span> -15 信号，让容器平滑的终止，等待 30 秒的宽限期，如果没有终止，那么则发送 <span class="built_in">kill</span> 信号</span><br></pre></td></tr></table></figure>
<h3 id="hostNetwork-主机网络空间"><a href="#hostNetwork-主机网络空间" class="headerlink" title="hostNetwork 主机网络空间"></a>hostNetwork 主机网络空间</h3><p>使用布尔值指定是否让 POD 使用主机的网络名称空间</p>
<h3 id="hostPID-主机PID空间"><a href="#hostPID-主机PID空间" class="headerlink" title="hostPID 主机PID空间"></a>hostPID 主机PID空间</h3><p>使用布尔值指定是否让 POD 使用主机的PID名称空间</p>
<h3 id="containers-配置"><a href="#containers-配置" class="headerlink" title="containers 配置"></a>containers 配置</h3><blockquote>
<p>  kubectl explain pods.spec.containers</p>
</blockquote>
<p>描述 POD 内所运行容器，语法：containers &lt;[]Object&gt;，表示它的值为数组，数组内使用对象的方式来描述一个容器，对象可以有以下参数：</p>
<ul>
<li>可用参数</li>
</ul>
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>args</td>
<td></td>
</tr>
<tr>
<td>command</td>
<td></td>
</tr>
<tr>
<td>env</td>
<td>向容器传递环境变量</td>
</tr>
<tr>
<td>envFrom</td>
<td></td>
</tr>
<tr>
<td>image</td>
<td></td>
</tr>
<tr>
<td>imagePullPolicy</td>
<td></td>
</tr>
<tr>
<td>lifecycle</td>
<td></td>
</tr>
<tr>
<td>livenessProbe</td>
<td></td>
</tr>
<tr>
<td>name</td>
<td></td>
</tr>
<tr>
<td>ports</td>
<td></td>
</tr>
<tr>
<td>readinessProbe</td>
<td></td>
</tr>
<tr>
<td>resources</td>
<td></td>
</tr>
<tr>
<td>securityContext</td>
<td></td>
</tr>
<tr>
<td>stdin</td>
<td></td>
</tr>
<tr>
<td>stdinOnce</td>
<td></td>
</tr>
<tr>
<td>terminationMessagePath</td>
<td></td>
</tr>
<tr>
<td>terminationMessagePolicy</td>
<td></td>
</tr>
<tr>
<td>tty</td>
<td></td>
</tr>
<tr>
<td>volumeDevices</td>
<td></td>
</tr>
<tr>
<td>volumeMounts</td>
<td></td>
</tr>
<tr>
<td>workingDir</td>
</tr>
</tbody>
</table>
<ul>
<li>示例型配置</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: pod-deme                     <span class="comment"># pod 的名称</span></span><br><span class="line">  namespace: default</span><br><span class="line">  labels:</span><br><span class="line">    app: myapp</span><br><span class="line">    tier: frontend</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">    - name: myapp                      <span class="comment"># 运行的容器名称</span></span><br><span class="line">      image: ikubernetes/myapp:v1      <span class="comment"># 容器的镜像</span></span><br><span class="line">      imagePullPolicy: IfNotPresent    <span class="comment"># 从仓库获取镜像的策略</span></span><br><span class="line">      ports:                           <span class="comment"># 定义容器暴漏的端口</span></span><br><span class="line">    - name: busybox</span><br><span class="line">      image: busybox:latest</span><br><span class="line">      <span class="built_in">command</span>:</span><br><span class="line">        - <span class="string">"/bin/sh"</span></span><br><span class="line">        - <span class="string">"-c"</span></span><br><span class="line">        - <span class="string">"sleep 10"</span></span><br></pre></td></tr></table></figure>
<h4 id="imagePullPolicy下载策略"><a href="#imagePullPolicy下载策略" class="headerlink" title="imagePullPolicy下载策略"></a>imagePullPolicy下载策略</h4><ul>
<li>imagePullPolicy 镜像获取的策略，详见：<code>kubectl explain pods.spec.containers</code></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Always            <span class="comment"># 总是从仓库下载</span></span><br><span class="line">Never             <span class="comment"># 从不下载，本地有就用，没有就失败</span></span><br><span class="line">IfNotPresent      <span class="comment"># 如果本地存在就直接使用，如果不存在就下载</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>  如果标签是 latest 那么则始终从仓库下载</p>
</blockquote>
<h4 id="ports-端口信息"><a href="#ports-端口信息" class="headerlink" title="ports 端口信息"></a>ports 端口信息</h4><ul>
<li>ports 定义容器保暴露的，详见：<code>kubectl explain pods.spec.containers.ports</code></li>
</ul>
<p>在此处暴露的端口可为系统提供有关容器的网络连接的信息，但主要是信息性的，此处没有指定的端口也不会阻止容器暴露该端口，容器中任何侦听 0.0.0.0 地址的端口都可以从网络访问</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">ports:</span>                    <span class="comment"># 定义两个端口对象一个 http 一个 https</span></span><br><span class="line"><span class="attr">- name:</span> <span class="string">http</span>              <span class="comment"># 定义这个端口的名称，方便别的对象取引用</span></span><br><span class="line"><span class="attr">  containerPort:</span> <span class="number">80</span>       <span class="comment"># 端口号</span></span><br><span class="line"><span class="attr">- name:</span> <span class="string">https</span>             <span class="comment"># 方便引用的名称</span></span><br><span class="line"><span class="attr">  containerPort:</span> <span class="number">443</span>      <span class="comment"># 这个端口号仅仅是起到信息的作用，方便查看和使用名称引用</span></span><br></pre></td></tr></table></figure>
<h4 id="env-传递环境变量"><a href="#env-传递环境变量" class="headerlink" title="env 传递环境变量"></a>env 传递环境变量</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="command-ENTRYPOINT"><a href="#command-ENTRYPOINT" class="headerlink" title="command ENTRYPOINT"></a>command ENTRYPOINT</h4><ul>
<li>command 定义容器运行的程序，详见：</li>
</ul>
<p>一个 entrypoint array 而 command 启动的程序是不会运行在 Shell 中的，如果想要运行在 Shell 中需要自己填写，如果没有提供这个指令，那么将运行 docker 镜像中的 ENTRYPOINT。</p>
<h4 id="args-CMD"><a href="#args-CMD" class="headerlink" title="args CMD"></a>args CMD</h4><ul>
<li>args 向 command 传递参数的</li>
</ul>
<p>如果你没有定义 args 而镜像中又存在 ENTRYPOINT 指令和 CMD 指令，那么镜像自己的 CMD 将作为参数传递给 ENTRYPOINT。如果手动指定了 args 那么镜像中的 CMD 字段不再作为参数进行传递。</p>
<p>如果在 args 中引用了变量，则需要使用 $(VAR_NAME) 来引用一个变量，如果不想在这里进行命令替换，那么可以 $$(VAR_NAME)，转义后在容器内使用。</p>
<h4 id="annotations-注解信息"><a href="#annotations-注解信息" class="headerlink" title="annotations 注解信息"></a>annotations 注解信息</h4><p>annotations 与 label 不同的地方在于，它不能用于挑选资源对象，仅为对象提供元数据，它的长度不受限制</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">pod-deme</span></span><br><span class="line"><span class="attr">  namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">  labels:</span></span><br><span class="line"><span class="attr">    app:</span> <span class="string">myapp</span></span><br><span class="line"><span class="attr">    tier:</span> <span class="string">frontend</span></span><br><span class="line"><span class="attr">  annotations:</span>                                      <span class="comment"># 注解关键字</span></span><br><span class="line">    <span class="string">jinheng/created-by:</span> <span class="string">"yangjinheng"</span>               <span class="comment"># 添加键值对的资源注解</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">myapp</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">ikubernetes/myapp:v1</span></span><br><span class="line"><span class="attr">    imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br></pre></td></tr></table></figure>
<h4 id="POD-生命周期"><a href="#POD-生命周期" class="headerlink" title="POD 生命周期"></a>POD 生命周期</h4><ul>
<li>一般状态</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Pending：已经创建但是没有适合运行它的节点，已经调度，但是尚未完成</span><br><span class="line">Running：运行状态</span><br><span class="line">Failed： 启动失败</span><br><span class="line">Succeed：成功，这个状态很短</span><br><span class="line">Unkown： 未知的状态，如果 Apiserver 与 kubelet 通信失败则会处于这个状态</span><br></pre></td></tr></table></figure>
<ul>
<li>创建 POD 阶段</li>
</ul>
<p>用户的创建请求提交给 apiserver ，而 apiserver 会将请求的目标状态保存在 etcd 中，而后 apiserver 会请求 schedule 进行调度，并且把调度的结果更新在 etcd 的 pod 状态中，随后一旦保存在 etcd 中，并完成 schedule 更新后目标节点的 kubelet 就会从 etcd 的状态变化得知有新任务给自己，所以此时会拿到用户所希望的资源清单目标状态，根据清单在当前节点运行这个 POD，如果创建成功或者失败，则将结果发回给 apiserver ，apiserver 再次保存在 etcd 中。</p>
<h4 id="livenessProbe-存活性探测"><a href="#livenessProbe-存活性探测" class="headerlink" title="livenessProbe 存活性探测"></a>livenessProbe 存活性探测</h4><blockquote>
<p>  详细见：kubectl explain pods.spec.containers.livenessProbe</p>
</blockquote>
<ul>
<li>livenessProbe / readinessProbe 是 k8s 两个生命周期，这两个生命周期都可以定义探针来探测容器状态做出不同反应</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">livenessProbe     <span class="comment"># 指示容器是否正在运行。如果存活探测失败，则依据 restartPolicy 策略来进行重启</span></span><br><span class="line">readinessProbe    <span class="comment"># 指示容器是否准备好服务请求。如果就绪探测失败端点控制器将从与 Pod 匹配的所有 Service 的端点中删除该 Pod 的 IP 地址</span></span><br></pre></td></tr></table></figure>
<ul>
<li>livenessProbe / readinessProbe 可用的探针和探针特性，探针只能定义一种类型，例如：HTTPGetAction</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">exec</span>          <span class="comment"># 在容器内执行指定命令。如果命令退出时返回码为 0 则认为诊断成功。</span></span><br><span class="line">tcpSocket     <span class="comment"># 对指定端口上的容器的 IP 地址进行 TCP 检查。如果端口打开，则诊断被认为是成功的。</span></span><br><span class="line">httpGet       <span class="comment"># HTTP GET 请求指定端口和路径上的容器。如果响应码大于等于200 且小于 400，则诊断被认为是成功的。</span></span><br></pre></td></tr></table></figure>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">failureThreshold</span>    <span class="comment"># 探测几次才判定为探测失败，默认为 3 次。</span></span><br><span class="line"><span class="string">periodSeconds</span>       <span class="comment"># 每次探测周期的间隔时长。</span></span><br><span class="line"><span class="string">timeoutSeconds</span>      <span class="comment"># 每次探测发出后等待结果的超时时间，默认为 1 秒。</span></span><br><span class="line"><span class="string">initalDelaySeconds</span>  <span class="comment"># 在容器启动后延迟多久去进行探测，默认为启动容器后立即探测。</span></span><br></pre></td></tr></table></figure>
<ul>
<li>使用 exec 探针，实验结果应该为 39 秒后 POD 显示 ERROR ，但不自动重启 POD</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: execlive</span><br><span class="line">  namespace: default</span><br><span class="line">  labels:</span><br><span class="line">    app: myapp</span><br><span class="line">    tier: frontend</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">    - name: busybox</span><br><span class="line">      image: busybox</span><br><span class="line">      <span class="built_in">command</span>:</span><br><span class="line">        - <span class="string">"/bin/sh"</span></span><br><span class="line">        - <span class="string">"-c"</span></span><br><span class="line">        - <span class="string">"touch /tmp/healthy; sleep 30; rm -rf /tmp/healthy; sleep 3600"</span>    <span class="comment"># 创建一个文件等待 30 秒，这个时间探针应该是成功的，30 秒后则失败</span></span><br><span class="line">      livenessProbe:                                   <span class="comment"># 容器的存活性检测，如果失败则按照 restartPolicy 策略来重启 POD</span></span><br><span class="line">        <span class="built_in">exec</span>:                                          <span class="comment"># exec 类型探针，进入容器执行一条命令</span></span><br><span class="line">          <span class="built_in">command</span>: [<span class="string">"test"</span>, <span class="string">"-e"</span> ,<span class="string">"/tmp/healthy"</span>]      <span class="comment"># 执行的命令为测试文件存在性</span></span><br><span class="line">        initialDelaySeconds: 2                         <span class="comment"># 容器启动后延迟多久进行探测</span></span><br><span class="line">        periodSeconds: 3                               <span class="comment"># 每次探测周期的间隔时长为 3 秒</span></span><br><span class="line">        failureThreshold: 3                            <span class="comment"># 3 次失败后则判定为容器探测存活性失败</span></span><br><span class="line">  restartPolicy: Never                                 <span class="comment"># 当探测到容器失败是否重启 POD</span></span><br></pre></td></tr></table></figure>
<ul>
<li>使用 httpGet 探针，实验结果应该大约 40 秒后探测存活性失败，自动重启 POD，第一次重启会立即进行，随后是 30 秒的2倍直到 300 秒。</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">httpgetlive</span></span><br><span class="line"><span class="attr">  namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">  labels:</span></span><br><span class="line"><span class="attr">    app:</span> <span class="string">myapp</span></span><br><span class="line"><span class="attr">    tier:</span> <span class="string">frontend</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">      image:</span> <span class="string">ikubernetes/myapp:v1</span></span><br><span class="line"><span class="attr">      ports:</span></span><br><span class="line"><span class="attr">        - name:</span> <span class="string">http</span></span><br><span class="line"><span class="attr">          containerPort:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">        - name:</span> <span class="string">https</span></span><br><span class="line"><span class="attr">          containerPort:</span> <span class="number">443</span></span><br><span class="line"><span class="attr">      livenessProbe:</span>                   <span class="comment"># 容器的存活性检测，如果失败则按照 restartPolicy 策略来重启 POD</span></span><br><span class="line"><span class="attr">        httpGet:</span>                       <span class="comment"># httpget 探针</span></span><br><span class="line"><span class="attr">          path:</span> <span class="string">/error.html</span>            <span class="comment"># 探测的页面，为了效果这个页面不存在</span></span><br><span class="line"><span class="attr">          port:</span> <span class="string">http</span>                   <span class="comment"># 探测的端口，使用名称引用容器的端口</span></span><br><span class="line"><span class="attr">          httpHeaders:</span>                 <span class="comment"># httpget 时候设置请求头</span></span><br><span class="line"><span class="attr">            - name:</span> <span class="string">X-Custom-Header</span></span><br><span class="line"><span class="attr">              value:</span> <span class="string">Awesome</span></span><br><span class="line"><span class="attr">        initialDelaySeconds:</span> <span class="number">15</span>        <span class="comment"># 容器启动后延迟多久进行探测</span></span><br><span class="line"><span class="attr">        timeoutSeconds:</span> <span class="number">1</span>              <span class="comment"># 每次探测发出等待结果的时长</span></span><br><span class="line"><span class="attr">  restartPolicy:</span> <span class="string">Always</span>                <span class="comment"># 当探测到容器失败是否重启 POD</span></span><br></pre></td></tr></table></figure>
<h4 id="readinessProbe-就绪性检测"><a href="#readinessProbe-就绪性检测" class="headerlink" title="readinessProbe 就绪性检测"></a>readinessProbe 就绪性检测</h4><p>例如有一个容器运行的是 tomcat ，而 tomcat 展开 war 包，部署完成的时间可能较长，而默认 k8s 会在容器启动就标记为 read 状态，接收 service 的调度请求，但是容器启动不代表 tomcat 已经成功运行，所以需要 readinessProbe 进行就绪性探测，来决定是否可以接入 service 上。</p>
<ul>
<li>livenessProbe / readinessProbe 可用的探针和探针特性基本一样，探针只能定义一种类型，例如：HTTPGetAction</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">livenessProbe     <span class="comment"># 指示容器是否正在运行。如果存活探测失败，则依据 restartPolicy 策略来进行重启</span></span><br><span class="line">readinessProbe    <span class="comment"># 指示容器是否准备好服务请求。如果就绪探测失败端点控制器将从与 Pod 匹配的所有 Service 的端点中删除该 Pod 的 IP 地址</span></span><br></pre></td></tr></table></figure>
<ul>
<li>使用 httpGet 探针，实验结果应该大约 40 秒后探测存活性失败，自动重启 POD，第一次重启会立即进行，随后是 30 秒的2倍直到 300 秒。</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">httpgetread</span></span><br><span class="line"><span class="attr">  namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">  labels:</span></span><br><span class="line"><span class="attr">    app:</span> <span class="string">myapp</span></span><br><span class="line"><span class="attr">    tier:</span> <span class="string">frontend</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">      image:</span> <span class="string">ikubernetes/myapp:v1</span></span><br><span class="line"><span class="attr">      ports:</span></span><br><span class="line"><span class="attr">        - name:</span> <span class="string">http</span></span><br><span class="line"><span class="attr">          containerPort:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">        - name:</span> <span class="string">https</span></span><br><span class="line"><span class="attr">          containerPort:</span> <span class="number">443</span></span><br><span class="line"><span class="attr">      livenessProbe:</span>                   <span class="comment"># 容器的存活性检测，如果失败则按照 restartPolicy 策略来重启 POD</span></span><br><span class="line"><span class="attr">        httpGet:</span>                       <span class="comment"># httpget 探针</span></span><br><span class="line"><span class="attr">          path:</span> <span class="string">/error.html</span>            <span class="comment"># 探测的页面，为了效果这个页面不存在</span></span><br><span class="line"><span class="attr">          port:</span> <span class="string">http</span>                   <span class="comment"># 探测的端口，使用名称引用容器的端口</span></span><br><span class="line"><span class="attr">          httpHeaders:</span>                 <span class="comment"># httpget 时候设置请求头</span></span><br><span class="line"><span class="attr">            - name:</span> <span class="string">X-Custom-Header</span></span><br><span class="line"><span class="attr">              value:</span> <span class="string">Awesome</span></span><br><span class="line"><span class="attr">        initialDelaySeconds:</span> <span class="number">15</span>        <span class="comment"># 容器启动后延迟多久进行探测</span></span><br><span class="line"><span class="attr">        timeoutSeconds:</span> <span class="number">1</span>              <span class="comment"># 每次探测发出等待结果的时长</span></span><br><span class="line"><span class="attr">  restartPolicy:</span> <span class="string">Always</span>                <span class="comment"># 当探测到容器失败是否重启 POD</span></span><br></pre></td></tr></table></figure>
<ul>
<li>手动进入容器，删除 index.html 以触发就绪性探针的检测</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl <span class="built_in">exec</span> -it httpgetread -- /bin/sh</span><br><span class="line">$ rm -f /usr/share/nginx/html/index.html</span><br></pre></td></tr></table></figure>
<ul>
<li>结果这个 POD 的 READY 状态已经变成非就绪了，此时 service 不会再调度到这个节点了</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node1 ~]<span class="comment"># kubectl get pods -w</span></span><br><span class="line">NAME                            READY   STATUS    RESTARTS   AGE</span><br><span class="line">httpgetread                     0/1     Running   0          2m50s</span><br></pre></td></tr></table></figure>
<ul>
<li>在容器内再创建一个文件，以触发就绪性探针的检测</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl <span class="built_in">exec</span> -it httpgetread -- /bin/sh</span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">"hello worlld"</span> &gt;&gt;/usr/share/nginx/html/index.html</span><br></pre></td></tr></table></figure>
<ul>
<li>结果这个 POD 的的 READY 状态已经编程就绪了，此时 service 会调度到这个节点了</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node1 ~]<span class="comment"># kubectl get pods -w</span></span><br><span class="line">NAME                            READY   STATUS    RESTARTS   AGE</span><br><span class="line">httpgetread                     1/1     Running   0          8m15s</span><br></pre></td></tr></table></figure>
<h4 id="lifecycle-生命周期钩子"><a href="#lifecycle-生命周期钩子" class="headerlink" title="lifecycle 生命周期钩子"></a>lifecycle 生命周期钩子</h4><blockquote>
<p>  详见：kubectl explain pods.spec.containers.lifecycle</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">postStart           <span class="comment"># 在容器启动后立即执行的命令，如果这个操作失败了，那么容器会终止，且根据 restartPolicy 来决定是否重启</span></span><br><span class="line">preStop             <span class="comment"># 在容器终止前立即执行的命令</span></span><br></pre></td></tr></table></figure>
<ul>
<li>postStart / preStop 的基本使用</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: lifecycle-demo</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: lifecycle-demo-container</span><br><span class="line">    image: nginx</span><br><span class="line"></span><br><span class="line">    lifecycle:</span><br><span class="line">      postStart:</span><br><span class="line">        <span class="built_in">exec</span>:</span><br><span class="line">          <span class="built_in">command</span>: [<span class="string">"/bin/sh"</span>, <span class="string">"-c"</span>, <span class="string">"echo Hello from the postStart handler &gt; /usr/share/message"</span>]</span><br><span class="line">      preStop:</span><br><span class="line">        <span class="built_in">exec</span>:</span><br><span class="line">          <span class="built_in">command</span>: [<span class="string">"/usr/sbin/nginx"</span>,<span class="string">"-s"</span>,<span class="string">"quit"</span>]</span><br></pre></td></tr></table></figure>
<p>POD控制器</p>
<p>控制器管理的 POD 可以实现，自动维护 POD 副本数量，它能实现 POD 的扩容和缩容，但是不能实现滚的那个更新等高级功能。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>ReplicationController</td>
<td>原来 k8s 只有这一种控制器，目前已经接近废弃</td>
</tr>
<tr>
<td>ReplicaSet</td>
<td>代用户创建指定数量的 POD 副本，还支持扩缩容，被称为新一代的 ReplicationController。主要由 3 个指标，1. 用户希望的 POD 副本，2. 标签选择器，判定 POD 是否归自己管理，3. 如果 POD 副本不够，按照哪个 POD template 创建 POD，但一般我们不直接使用 ReplicaSet。</td>
</tr>
<tr>
<td>Deployment</td>
<td>Deployment 通过控制 ReplicaSet 来实现功能，除了支持 ReplicaSet 的扩缩容意外，还支持滚动更新和回滚等，还提供了声明式的配置，这个是我们日常使用最多的控制器。它是用来管理无状态的应用。</td>
</tr>
<tr>
<td>DaemonSet</td>
<td>用于确保集群内的每个 node 上只运行一个指定的 POD，如果有新增的节点也都会自动运行这个 POD，所以这个控制器无需定义 POD 运行的数量，只需要定义标签选择器和 POD template。所以可以跟根据标签选择器选中的 node 上只运行一个 POD 副本。</td>
</tr>
<tr>
<td>Job</td>
<td>执行一个一次性任务，例如数据库备份，任务完成后正常退出，则 POD 不会再被启动了，除非任务异常终止。</td>
</tr>
<tr>
<td>CronJob</td>
<td>执行一些周期性任务</td>
</tr>
<tr>
<td>StatefulSet</td>
<td>管理有状态的 POD ，但是对每个不同的有状态应用需要自行编写脚本，完成对有状态服务的管理，为了解决 StatefulSet 不方便编写有状态应用管理的问题。k8s 还提供了 helm 这样类似于 yum 的方式，方便用户从 helm 市场来安装一个有状态的应用。</td>
</tr>
</tbody>
</table>
<h1 id="控制器配置清单"><a href="#控制器配置清单" class="headerlink" title="控制器配置清单"></a>控制器配置清单</h1><h2 id="ReplicaSet-控制器"><a href="#ReplicaSet-控制器" class="headerlink" title="ReplicaSet 控制器"></a>ReplicaSet 控制器</h2><blockquote>
<p>  详见：kubectl explain replicaset</p>
</blockquote>
<ul>
<li>清单规范</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion	&lt;string&gt;    <span class="comment"># api 版本号，一般为 apps/v1</span></span><br><span class="line"></span><br><span class="line">kind	    &lt;string&gt;    <span class="comment"># 资源类别，标记创建什么类型的资源</span></span><br><span class="line"></span><br><span class="line">metadata    &lt;Object&gt;    <span class="comment"># POD 元数据</span></span><br><span class="line"></span><br><span class="line">spec	    &lt;Object&gt;    <span class="comment"># 元数据</span></span><br></pre></td></tr></table></figure>
<h3 id="replicaset-spec-规范"><a href="#replicaset-spec-规范" class="headerlink" title="replicaset.spec 规范"></a>replicaset.spec 规范</h3><ol>
<li><p>replicas 副本数量，指定一个数字</p>
</li>
<li><p>selector 标签选择器，可以使用 matchLabels、matchExpressions 两种类型的选择器来选中目标 POD</p>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">matchLabels：直接给定键值</span><br><span class="line">matchExpressions：基于给定的表达式来定义使用标签选择器：&#123;key:<span class="string">"KEY"</span>,operator:<span class="string">"OPERATOR"</span>,value:[VAL1,VAL2,...]&#125;</span><br><span class="line">    使用 key 与 value 进行 operator 运算，复合条件的才被选择</span><br><span class="line">    操作符：</span><br><span class="line">    	In、NotIn：其 value 列表必须有值</span><br><span class="line">    	Exists、NotExists：其 value 必须为空</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>template 模板，这里面定义的就是一个 POD 对象，这个对象只包含了 pod.metadata 和 pod.spec 两部分。</li>
</ol>
<h3 id="清单示例"><a href="#清单示例" class="headerlink" title="清单示例"></a>清单示例</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ReplicaSet</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">myrs</span></span><br><span class="line"><span class="attr">  namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  replicas:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    matchLabels:</span></span><br><span class="line"><span class="attr">      app:</span> <span class="string">myapp</span></span><br><span class="line"><span class="attr">      release:</span> <span class="string">canary</span></span><br><span class="line"><span class="attr">  template:</span></span><br><span class="line"><span class="attr">    metadata:</span></span><br><span class="line"><span class="attr">      name:</span> <span class="string">myapp-pod</span>     <span class="comment"># 这个其实没用，因为创建的 POD 以 rs 的名字开头</span></span><br><span class="line"><span class="attr">      labels:</span></span><br><span class="line"><span class="attr">        app:</span> <span class="string">myapp</span>        <span class="comment"># 标签一定要符合 replicaset 标签选择器的规则，否则将陷入创建 pod 的死循环，直到资源耗尽</span></span><br><span class="line"><span class="attr">        release:</span> <span class="string">canary</span></span><br><span class="line"><span class="attr">    spec:</span></span><br><span class="line"><span class="attr">      containers:</span></span><br><span class="line"><span class="attr">        - name:</span> <span class="string">myapp-containers</span></span><br><span class="line"><span class="attr">          image:</span> <span class="string">ikubernetes/myapp:v1</span></span><br><span class="line"><span class="attr">          ports:</span></span><br><span class="line"><span class="attr">            - name:</span> <span class="string">http</span></span><br><span class="line"><span class="attr">              containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>
<h2 id="Deployment控制器"><a href="#Deployment控制器" class="headerlink" title="Deployment控制器"></a>Deployment控制器</h2><p>Deployment 通过控制 ReplicaSet 来实现功能，除了支持 ReplicaSet 的扩缩容意外，还支持滚动更新和回滚等，还提供了声明式的配置，这个是我们日常使用最多的控制器。它是用来管理无状态的应用。</p>
<p>Deployment 在滚动更新时候，通过控制多个 ReplicaSet 来实现，ReplicaSet 又控制多个 POD，多个 ReplicaSet 相当于多个应用的版本。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">graph TB</span><br><span class="line">Deployment[Deployment] --&gt; replicaset1(replicaset1) </span><br><span class="line">Deployment[Deployment] --&gt; replicaset2(replicaset2)</span><br><span class="line">Deployment[Deployment] --&gt; replicaset3(replicaset3)</span><br><span class="line">replicaset1(replicaset1) --&gt; POD1&#123;POD&#125;</span><br><span class="line">replicaset1(replicaset1) --&gt; POD2&#123;POD&#125;</span><br><span class="line">replicaset2(replicaset1) --&gt; POD5&#123;POD&#125;</span><br><span class="line">replicaset2(replicaset1) --&gt; POD6&#123;POD&#125;</span><br><span class="line">replicaset3(replicaset1) --&gt; POD9&#123;POD&#125;</span><br><span class="line">replicaset3(replicaset1) --&gt; POD10&#123;POD&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>清单规范，详见：kubectl explain deployment</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion	&lt;string&gt;    <span class="comment"># apps/v1</span></span><br><span class="line"></span><br><span class="line">kind	    &lt;string&gt;    <span class="comment"># 资源类别，标记创建什么类型的资源</span></span><br><span class="line"></span><br><span class="line">metadata    &lt;Object&gt;    <span class="comment"># POD 元数据</span></span><br><span class="line"></span><br><span class="line">spec	    &lt;Object&gt;    <span class="comment"># 元数据</span></span><br></pre></td></tr></table></figure>
<h3 id="replicaset-spec-对象规范"><a href="#replicaset-spec-对象规范" class="headerlink" title="replicaset.spec 对象规范"></a>replicaset.spec 对象规范</h3><ol>
<li><p>replicas 副本数量，指定一个数字</p>
</li>
<li><p>selector 标签选择器，可以使用 matchLabels、matchExpressions 两种类型的选择器来选中目标 POD</p>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">matchLabels：直接给定键值</span><br><span class="line">matchExpressions：基于给定的表达式来定义使用标签选择器：&#123;key:<span class="string">"KEY"</span>,operator:<span class="string">"OPERATOR"</span>,value:[VAL1,VAL2,...]&#125;</span><br><span class="line">    使用 key 与 value 进行 operator 运算，复合条件的才被选择</span><br><span class="line">    操作符：</span><br><span class="line">    	In、NotIn：其 value 列表必须有值</span><br><span class="line">    	Exists、NotExists：其 value 必须为空</span><br></pre></td></tr></table></figure>
<ol start="3">
<li><p>template 模板，这里面定义的就是一个 POD 对象，这个对象只包含了 pod.metadata 和 pod.spec 两部分。</p>
</li>
<li><p>strategy 更新策略，支持滚动更新、支持滚动更新的更新方式</p>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">type</span>：                <span class="comment"># 更新类型，Recreate 滚动更新，RollingUpdate 滚动更新策略</span></span><br><span class="line">rollingUpdate：       <span class="comment"># 滚动更新时候的策略，这是默认的更新策略</span></span><br><span class="line">	maxSurge：        <span class="comment"># 滚动更新时候允许临时超出多少个，可以指定数量或者百分比，默认 25%</span></span><br><span class="line">	maxUnavailable：  <span class="comment"># 最多允许多少个 POD 不可用，默认 25%</span></span><br></pre></td></tr></table></figure>
<ol start="5">
<li><p>revisionHistoryLimit 滚动更新后最多保存多少个更新的历史版本，值为一个数字</p>
</li>
<li><p>paused 当更新启动后控制是否暂停</p>
</li>
</ol>
<h3 id="清单示例-1"><a href="#清单示例-1" class="headerlink" title="清单示例"></a>清单示例</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">myapp-deploy</span></span><br><span class="line"><span class="attr">  namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  replicas:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    matchLabels:</span></span><br><span class="line"><span class="attr">      app:</span> <span class="string">myapp</span></span><br><span class="line"><span class="attr">      release:</span> <span class="string">canary</span></span><br><span class="line"><span class="attr">  template:</span></span><br><span class="line"><span class="attr">    metadata:</span></span><br><span class="line"><span class="attr">      labels:</span></span><br><span class="line"><span class="attr">        app:</span> <span class="string">myapp</span></span><br><span class="line"><span class="attr">        release:</span> <span class="string">canary</span></span><br><span class="line"><span class="attr">    spec:</span></span><br><span class="line"><span class="attr">      containers:</span></span><br><span class="line"><span class="attr">        - name:</span> <span class="string">myapp</span></span><br><span class="line"><span class="attr">          image:</span> <span class="string">ikubernetes/myapp:v1</span></span><br><span class="line"><span class="attr">          ports:</span></span><br><span class="line"><span class="attr">            - name:</span> <span class="string">http</span></span><br><span class="line"><span class="attr">              containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>
<h3 id="关于更新"><a href="#关于更新" class="headerlink" title="关于更新"></a>关于更新</h3><ol>
<li>直接修改清单文件，kubectl apply -f deployment.yaml</li>
<li>使用 kubectl patch 使用 json 格式给出更新的内容</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl patch deployment myapp-deploy -p <span class="string">'&#123;"spec":&#123;"replicas":5&#125;&#125;'</span>    <span class="comment"># 修改 POD 副本数量</span></span><br><span class="line"></span><br><span class="line">kubectl patch deployment myapp-deploy -p <span class="string">'&#123;"spec":&#123;"strategy":&#123;"rollingUpdate":&#123;"maxSurge":1,"maxUnavailable":0&#125;&#125;&#125;&#125;'</span>                                 <span class="comment"># 修改更新策略</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>仅更新镜像 kubectl set image</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl <span class="built_in">set</span> image deployment myapp-deploy myapp=ikubernetes/myapp:v3</span><br></pre></td></tr></table></figure>
<h3 id="模拟金丝雀发布"><a href="#模拟金丝雀发布" class="headerlink" title="模拟金丝雀发布"></a>模拟金丝雀发布</h3><ul>
<li>在更新刚刚启动的时候，将更新过程暂停，那么只能更新一个，这实现了在集群中增加一个金丝雀版本</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl <span class="built_in">set</span> image deployment myapp-deploy myapp=ikubernetes/myapp:v3 &amp;&amp; kubectl rollout pause deployment myapp-deploy</span><br></pre></td></tr></table></figure>
<ul>
<li>查看已经被更新中被暂停的控制器状态，可以看到一直处于暂停状态的 deployment</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl rollout status deployment myapp-deploy</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Waiting <span class="keyword">for</span> deployment <span class="string">"myapp-deploy"</span> rollout to finish: 1 out of 5 new replicas have been updated...</span><br><span class="line"></span><br><span class="line">等待部署“myapp-deploy”部署完成：5个新副本中的1个已更新...</span><br></pre></td></tr></table></figure>
<ul>
<li>如果金丝雀没有问题，那么继续可以使用继续更新的命令</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl rollout resume deployment myapp-deploy</span><br></pre></td></tr></table></figure>
<h3 id="更新策略"><a href="#更新策略" class="headerlink" title="更新策略"></a>更新策略</h3><ul>
<li>最大不可用为 0 ，更新时候可以临时超出1个</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl patch deployment myapp-deploy -p <span class="string">'&#123;"spec":&#123;"strategy":&#123;"rollingUpdate":&#123;"maxSurge":1,"maxUnavailable":0&#125;&#125;&#125;&#125;'</span></span><br></pre></td></tr></table></figure>
<h3 id="关于回滚"><a href="#关于回滚" class="headerlink" title="关于回滚"></a>关于回滚</h3><ol>
<li>rollout undo 是回滚的命令，默认滚回上一版本</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl rollout undo deployment myapp-deploy</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>查看可以回滚的版本</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl rollout <span class="built_in">history</span> deployment myapp-deploy</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>rollout undo 指定回滚的版本</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl rollout undo deployment myapp-deploy --to-revision=2</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>查看当前的工作版本</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get rs -o wide</span><br></pre></td></tr></table></figure>
<h2 id="DaemonSet控制器"><a href="#DaemonSet控制器" class="headerlink" title="DaemonSet控制器"></a>DaemonSet控制器</h2><ul>
<li>清单规范，详见 kubectl explain daemonset</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion	&lt;string&gt;    <span class="comment"># apps/v1</span></span><br><span class="line"></span><br><span class="line">kind	    &lt;string&gt;    <span class="comment"># 资源类别，标记创建什么类型的资源</span></span><br><span class="line"></span><br><span class="line">metadata    &lt;Object&gt;    <span class="comment"># POD 元数据</span></span><br><span class="line"></span><br><span class="line">spec	    &lt;Object&gt;    <span class="comment"># 元数据</span></span><br></pre></td></tr></table></figure>
<h3 id="DaemonSet-spec规范"><a href="#DaemonSet-spec规范" class="headerlink" title="DaemonSet.spec规范"></a>DaemonSet.spec规范</h3><p>此处只列举不同之处</p>
<ol>
<li>updateStrategy 更新策略，支持滚动更新、支持滚动更新的更新方式，默认滚动更新每个 node</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rollingUpdate   <span class="comment"># 滚动更新，它只有一个 rollingUpdate 参数，表示每次更新几个 node 上的  DaemonSet 任务</span></span><br><span class="line">OnDelete        <span class="comment"># 在删除时更新</span></span><br></pre></td></tr></table></figure>
<h3 id="清单示例-2"><a href="#清单示例-2" class="headerlink" title="清单示例"></a>清单示例</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">redis</span></span><br><span class="line"><span class="attr">  namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  replicas:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    matchLabels:</span></span><br><span class="line"><span class="attr">      app:</span> <span class="string">redis</span></span><br><span class="line"><span class="attr">      role:</span> <span class="string">logstor</span></span><br><span class="line"><span class="attr">  template:</span></span><br><span class="line"><span class="attr">    metadata:</span></span><br><span class="line"><span class="attr">      labels:</span></span><br><span class="line"><span class="attr">        app:</span> <span class="string">redis</span></span><br><span class="line"><span class="attr">        role:</span> <span class="string">logstor</span></span><br><span class="line"><span class="attr">    spec:</span></span><br><span class="line"><span class="attr">      containers:</span></span><br><span class="line"><span class="attr">        - name:</span> <span class="string">redis</span></span><br><span class="line"><span class="attr">          image:</span> <span class="attr">redis:4.0-alpine</span></span><br><span class="line"><span class="attr">          ports:</span></span><br><span class="line"><span class="attr">            - name:</span> <span class="string">redis</span></span><br><span class="line"><span class="attr">              containerPort:</span> <span class="number">6379</span></span><br><span class="line"><span class="bullet">-</span><span class="bullet">--</span>                                         <span class="comment"># 可以使用 --- 来分隔多个记录</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">DaemonSet</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">filebeat-daemonset</span></span><br><span class="line"><span class="attr">  namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    matchLabels:</span></span><br><span class="line"><span class="attr">      app:</span> <span class="string">filebeat</span></span><br><span class="line"><span class="attr">      release:</span> <span class="string">stalbe</span></span><br><span class="line"><span class="attr">  template:</span></span><br><span class="line"><span class="attr">    metadata:</span></span><br><span class="line"><span class="attr">      labels:</span></span><br><span class="line"><span class="attr">        app:</span> <span class="string">filebeat</span></span><br><span class="line"><span class="attr">        release:</span> <span class="string">stalbe</span></span><br><span class="line"><span class="attr">    spec:</span></span><br><span class="line"><span class="attr">      containers:</span></span><br><span class="line"><span class="attr">        - name:</span> <span class="string">filebeat</span></span><br><span class="line"><span class="attr">          image:</span> <span class="string">ikubernetes/filebeat:5.6.5-alpine</span></span><br><span class="line"><span class="attr">          env:</span>                                         <span class="comment"># 向容器传递环境变量</span></span><br><span class="line"><span class="attr">            - name:</span> <span class="string">REDIS_HOST</span>                         <span class="comment"># 容器内的环境变量名称</span></span><br><span class="line"><span class="attr">              value:</span> <span class="string">redis.default.svc.cluster.local</span>   <span class="comment"># 环境变量值，指向 redis service</span></span><br><span class="line"><span class="attr">            - name:</span> <span class="string">REDIS_LOG_LEVEL</span></span><br><span class="line"><span class="attr">              value:</span> <span class="string">info</span></span><br></pre></td></tr></table></figure>
<h3 id="关于更新-1"><a href="#关于更新-1" class="headerlink" title="关于更新"></a>关于更新</h3><ul>
<li>更新 filebeat-daemonset 这个 daemonset 控制器下的 filebeat 容器的镜像</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl <span class="built_in">set</span> image daemonsets filebeat-daemonset filebeat=ikubernetes/filebeat:5.6.6-alpine</span><br></pre></td></tr></table></figure>
<h1 id="Service-配置清单"><a href="#Service-配置清单" class="headerlink" title="Service 配置清单"></a>Service 配置清单</h1><p>Service 为 POD 控制器控制的 POD 集群提供一个固定的访问端点，Service 的工作还依赖于 K8s 中的一个附件，就是 CoreDNS ，它将 Service 地址提供一个域名解析。</p>
<h2 id="Service-工作模式"><a href="#Service-工作模式" class="headerlink" title="Service 工作模式"></a>Service 工作模式</h2><ol>
<li>userspace: 1.1 之前版本</li>
<li>iptables: 1.10 之前版本</li>
<li>ipvs：1.11 之后版本</li>
</ol>
<h2 id="Service-类型"><a href="#Service-类型" class="headerlink" title="Service 类型"></a>Service 类型</h2><table>
<thead>
<tr>
<th>类型</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>ClusterIP</td>
<td>默认值，分配一个 Service 网络的地址，仅用于集群内部通信</td>
</tr>
<tr>
<td>NodePort</td>
<td>如果需要集群外部访问，可以使用这个类型</td>
</tr>
<tr>
<td>ExternalName</td>
<td>把集群外部的服务引入到集群内部，方便在集群内部使用</td>
</tr>
<tr>
<td>LoadBalancer</td>
<td>K8S 工作在云环境中，调用云环境创建负载均衡器</td>
</tr>
</tbody>
</table>
<h2 id="资源记录"><a href="#资源记录" class="headerlink" title="资源记录"></a>资源记录</h2><p>SVC_NAME.NS_NAME.DOMAIN.LTD</p>
<p>例如：redis.default.svc.cluster.local.</p>
<h2 id="Service-清单"><a href="#Service-清单" class="headerlink" title="Service 清单"></a>Service 清单</h2><ul>
<li>清单组成</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion	&lt;string&gt;    <span class="comment"># api 版本号，v1</span></span><br><span class="line"></span><br><span class="line">kind	    &lt;string&gt;    <span class="comment"># 资源类别，标记创建什么类型的资源</span></span><br><span class="line"></span><br><span class="line">metadata    &lt;Object&gt;    <span class="comment"># POD 元数据</span></span><br><span class="line"></span><br><span class="line">spec	    &lt;Object&gt;    <span class="comment"># 元数据</span></span><br></pre></td></tr></table></figure>
<h2 id="service-spec-规范"><a href="#service-spec-规范" class="headerlink" title="service.spec 规范"></a>service.spec 规范</h2><ol>
<li>clusterIP：指定 Service 处于 service 网络的哪个 IP，默认为动态分配</li>
<li>type： service 类型，可用：ExternalName, ClusterIP, NodePort, and LoadBalancer</li>
</ol>
<h2 id="ClusterIP-类型的-service"><a href="#ClusterIP-类型的-service" class="headerlink" title="ClusterIP 类型的 service"></a>ClusterIP 类型的 service</h2><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">redis</span></span><br><span class="line"><span class="attr">  namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    app:</span> <span class="string">redis</span></span><br><span class="line"><span class="attr">    role:</span> <span class="string">logstor</span></span><br><span class="line"><span class="attr">  type:</span> <span class="string">ClusterIP</span></span><br><span class="line"><span class="attr">  clusterIP:</span> <span class="number">10.96</span><span class="number">.0</span><span class="number">.100</span></span><br><span class="line"><span class="attr">  ports:</span></span><br><span class="line"><span class="attr">    - port:</span> <span class="number">6379</span>         <span class="comment"># service 端口</span></span><br><span class="line"><span class="attr">      targetPort:</span> <span class="number">6379</span>   <span class="comment"># pod 监听的端口</span></span><br><span class="line"><span class="attr">      protocol:</span> <span class="string">TCP</span></span><br></pre></td></tr></table></figure>
<h2 id="NodePort-类型的-service"><a href="#NodePort-类型的-service" class="headerlink" title="NodePort 类型的 service"></a>NodePort 类型的 service</h2><p>NodePort 是在 ClusterIP 类型上增加了一个暴露在了 node 的网络命名空间上的一个 nodePort，所以用户可以从集群外部访问到集群了，因而用户的请求流程是：Client -&gt; NodeIP:NodePort -&gt; ClusterIP:ServicePort -&gt; PodIP:ContainerPort。</p>
<p>可以理解为 NodePort 增强了 ClusterIP 的功能，让客户端可以在每个集群外部访问任意一个 nodeip 从而访问到 clusterIP，再由 clusterIP 进行负载均衡至 POD。</p>
<ul>
<li>清单示例</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">myapp</span></span><br><span class="line"><span class="attr">  namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    app:</span> <span class="string">myapp</span></span><br><span class="line"><span class="attr">    release:</span> <span class="string">canary</span></span><br><span class="line"><span class="attr">  type:</span> <span class="string">NodePort</span></span><br><span class="line"><span class="attr">  ports:</span></span><br><span class="line"><span class="attr">    - port:</span> <span class="number">80</span>         <span class="comment"># service 端口</span></span><br><span class="line"><span class="attr">      targetPort:</span> <span class="number">80</span>   <span class="comment"># pod 监听的端口</span></span><br><span class="line"><span class="attr">      nodePort:</span> <span class="number">30080</span>    <span class="comment"># service 会在每个 node 上添加 iptables/ipvs 规则重定向这个端口的访问，所以必须保证所有 node 的这个端口没被占用</span></span><br><span class="line"><span class="attr">      protocol:</span> <span class="string">TCP</span></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">在集群外部就可以使用：http://172.16.100.102:30080 来访问这个 service 地址了</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">在集群内可以使用 service 的域名在 coredns 上解析得到 service 地址：dig -t A myapp.default.svc.cluster.local @10.96.0.10</span><br></pre></td></tr></table></figure>
<h2 id="loadBalancerIP-类型"><a href="#loadBalancerIP-类型" class="headerlink" title="loadBalancerIP 类型"></a>loadBalancerIP 类型</h2><p>service 在每台主机的 iptables/ipvs 规则内，访问任意一台 node 都可以到达 pod，所以应该在这些 nodeip 前加负载均衡器，如果工作在公有云，可以使用 k8s 内置的 loadBalancerIP，操作公有云的负载均衡器即服务，实现动态的增删。</p>
<p>可以理解为 loadBalancerIP 增强了 NodePort 类型的 service ，在集群外部对每台 nodeip 进行负载均衡。</p>
<h2 id="无集群地址的-Service"><a href="#无集群地址的-Service" class="headerlink" title="无集群地址的 Service"></a>无集群地址的 Service</h2><p>无头 service 表示 service 没有 ClusterIP 也不映射 NodePort，而是将 service 的域名直接解析为 nodeIP 从而直接访问 nodeIP 上的 POD。</p>
<ul>
<li>清单示例</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: myapp-nohead</span><br><span class="line">  namespace: default</span><br><span class="line">spec:</span><br><span class="line">  selector:</span><br><span class="line">    app: myapp-nohead</span><br><span class="line">    release: canary</span><br><span class="line">  type: ClusterIP</span><br><span class="line">  clusterIP: None</span><br><span class="line">  ports:</span><br><span class="line">    - port: 80         # service 端口</span><br><span class="line">      targetPort: 80   # pod 监听的端口</span><br></pre></td></tr></table></figure>
<ul>
<li>查看 CoreDNS 服务器的地址</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get svc -n kube-system</span><br></pre></td></tr></table></figure>
<ul>
<li>在集群内使用 CoreDNS 的地址解析无头的 serive 域名，得到的直接为 nodeip 中的 pod 地址，利用 dns 的多条 A 记录来负载均衡</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dig -t A myapp-nohead.default.svc.cluster.local. @10.96.0.10</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">;; ANSWER SECTION:</span><br><span class="line">myapp-nohead.default.svc.cluster.local.	5 IN A	10.244.1.75</span><br><span class="line">myapp-nohead.default.svc.cluster.local.	5 IN A	10.244.2.74</span><br></pre></td></tr></table></figure>
<h2 id="externalName-类型"><a href="#externalName-类型" class="headerlink" title="externalName 类型"></a>externalName 类型</h2><p>当 POD 需要访问一个集群外部的服务时候，externalName 可以映射一个集群外部的服务到集群内部，供集群内 POD 访问。</p>
<p>就是把外部的一个域名地址，映射为集群内部 coredns 解析的一个内部地址，提供集群内部访问。</p>
<h1 id="ingress-控制器"><a href="#ingress-控制器" class="headerlink" title="ingress 控制器"></a>ingress 控制器</h1><p>如果 k8s 需要提供一个网站，并且这个站点需要以 https 访问，而 iptables/ipvs 工作在 4 层，客户发出的 ssl 请求根本不被解析就被调度到后端 POD了。解决方法有两个：</p>
<ol>
<li><p>可以在公有云的负载均衡器上配置上 ssl 证书。</p>
</li>
<li><p>新建一个负载均衡器的 POD ，例如 nignx ，这个 POD 共享主机的网络命名空间，也就是说可以直接通过 nodeip 访问到负载均衡器，ssl 证书配置在这个负载均衡器上，对外连接为 https 而对内的代理为 http 协议到 POD 网络的 POD 上。</p>
</li>
</ol>
<ul>
<li>存在的问题</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">- 负载均衡器 POD 使用节点的网络名称空间，那么它只能在这个 node 节点上运行一个了，否则就出现端口冲突。</span><br><span class="line">- 负载均衡器是代理 POD 卸载 ssl 证书的关键节点，它不能只运行一个，它需要在所有节点运行一个。</span><br></pre></td></tr></table></figure>
<ul>
<li>解决方法</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">- 负载均衡器使用 DaemonSet 在每个 node 节点运行一个，代理请求至 POD 网络的中的 POD 上。</span><br><span class="line">- 如果集群节点非常的多，其实不必在每个 node 节点都必须运行一个负载均衡器 POD。</span><br><span class="line">- 控制负载均衡器 POD 运行的数量可以通过 lables 指定运行那几个 node 节点上。</span><br><span class="line">- 然后可以在负载均衡器 POD 所在的 node 节点上打上 “污点” 使其他的 POD 不会再被调度上来，而只有负载均衡器 POD 可以容忍这些 “污点”。</span><br></pre></td></tr></table></figure>
<ul>
<li>负载均衡器可选，按照优先级先后排序</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Envoy            <span class="comment"># </span></span><br><span class="line">Traefik          <span class="comment"># 为微服务而生的反向代理</span></span><br><span class="line">Nginx            <span class="comment"># 改造后可以适用于微服务环境</span></span><br><span class="line">HAproxy          <span class="comment"># 不推荐使用</span></span><br></pre></td></tr></table></figure>
<p>新建一个 service 将需要代理的不同服务的 pod 分类</p>
<p>新建一个 ingress 资源，从 service 中取得分类结果，映射进 Envoy 中，重载 Envoy 软件。</p>
<h2 id="ingress-spec-规范"><a href="#ingress-spec-规范" class="headerlink" title="ingress.spec 规范"></a>ingress.spec 规范</h2><ul>
<li>API 和 kind</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion：extensions</span><br><span class="line"></span><br><span class="line">kind：ingress</span><br></pre></td></tr></table></figure>
<ul>
<li>ingress.spec</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">backend         <span class="comment"># 后端有哪些 POD</span></span><br><span class="line">rules           <span class="comment"># 调度规则</span></span><br><span class="line">    host        <span class="comment"># 虚拟主机</span></span><br><span class="line">    http        <span class="comment"># http 路径</span></span><br></pre></td></tr></table></figure>
<h2 id="ingress-nginx-代理"><a href="#ingress-nginx-代理" class="headerlink" title="ingress-nginx 代理"></a>ingress-nginx 代理</h2><ul>
<li>后端 service 和 pods</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">service-ingress-myapp</span></span><br><span class="line"><span class="attr">  namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    app:</span> <span class="string">myapp</span></span><br><span class="line"><span class="attr">    release:</span> <span class="string">canary</span></span><br><span class="line"><span class="attr">  ports:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">http</span></span><br><span class="line"><span class="attr">      port:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">      targetPort:</span> <span class="number">80</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">myapp</span></span><br><span class="line"><span class="attr">  namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  replicas:</span> <span class="number">4</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    matchLabels:</span></span><br><span class="line"><span class="attr">      app:</span> <span class="string">myapp</span></span><br><span class="line"><span class="attr">      release:</span> <span class="string">canary</span></span><br><span class="line"><span class="attr">  template:</span></span><br><span class="line"><span class="attr">    metadata:</span></span><br><span class="line"><span class="attr">      labels:</span></span><br><span class="line"><span class="attr">        app:</span> <span class="string">myapp</span></span><br><span class="line"><span class="attr">        release:</span> <span class="string">canary</span></span><br><span class="line"><span class="attr">    spec:</span></span><br><span class="line"><span class="attr">      containers:</span></span><br><span class="line"><span class="attr">        - name:</span> <span class="string">myapp</span></span><br><span class="line"><span class="attr">          image:</span> <span class="string">ikubernetes/myapp:v2</span></span><br><span class="line"><span class="attr">          ports:</span></span><br><span class="line"><span class="attr">            - name:</span> <span class="string">http</span></span><br><span class="line"><span class="attr">              containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>
<ul>
<li>创建 ingress-nginx</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/master/deploy/mandatory.yaml</span><br></pre></td></tr></table></figure>
<ul>
<li>让 ingress-nginx 在集群外部访问</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/master/deploy/provider/baremetal/service-nodeport.yaml</span><br></pre></td></tr></table></figure>
<ul>
<li>创建 ingress 对象，它能将 ingress-nginx 与 service 关联，从而在 service 后主机发生变动的时候，反应在 ingress-nginx 这个容器的配置文件中</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">ingress-deploy-myapp</span></span><br><span class="line"><span class="attr">  namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">  annotations:</span></span><br><span class="line">    <span class="string">kubernetes.io/ingress.class:</span> <span class="string">"nginx"</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  rules:</span></span><br><span class="line"><span class="attr">    - host:</span> <span class="string">myapp.jinheng.com</span>                       <span class="comment"># 基于主机名的访问</span></span><br><span class="line"><span class="attr">      http:</span></span><br><span class="line"><span class="attr">        paths:</span></span><br><span class="line"><span class="attr">          - path:</span>                                   <span class="comment"># 空的时候代表根，访问根的时候映射到 backend</span></span><br><span class="line"><span class="attr">            backend:</span>                                <span class="comment"># 后端的 service 的配置</span></span><br><span class="line"><span class="attr">              serviceName:</span> <span class="string">service-ingress-myapp</span>    <span class="comment"># 关联 service 从而获取到后端主机的变动</span></span><br><span class="line"><span class="attr">              servicePort:</span> <span class="number">80</span>                       <span class="comment"># 关联 service 的地址</span></span><br></pre></td></tr></table></figure>
<ul>
<li>查看 ingress-nginx 对外暴露的端口，这里为30080，和 30443 两个</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get service -n ingress-nginx</span><br></pre></td></tr></table></figure>
<ul>
<li>使用 nodeip + ingress-nginx 暴露端口访问，由于上面创建的 ingress 为基于主机名称的，所以需要在访问时在 /etc/hosts 做好映射到 node。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">http://myapp.jinheng.com:30080/index.html</span><br></pre></td></tr></table></figure>
<h2 id="ingress-tomcat-代理"><a href="#ingress-tomcat-代理" class="headerlink" title="ingress-tomcat 代理"></a>ingress-tomcat 代理</h2><ul>
<li>后端 service 和 pods</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">service-ingress-tomcat</span></span><br><span class="line"><span class="attr">  namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    app:</span> <span class="string">tomcat</span></span><br><span class="line"><span class="attr">    release:</span> <span class="string">canary</span></span><br><span class="line"><span class="attr">  ports:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">http</span></span><br><span class="line"><span class="attr">      port:</span> <span class="number">8080</span></span><br><span class="line"><span class="attr">      targetPort:</span> <span class="number">8080</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">ajp</span></span><br><span class="line"><span class="attr">      port:</span> <span class="number">8009</span></span><br><span class="line"><span class="attr">      targetPort:</span> <span class="number">8009</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">deploy-tomcat</span></span><br><span class="line"><span class="attr">  namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  replicas:</span> <span class="number">4</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    matchLabels:</span></span><br><span class="line"><span class="attr">      app:</span> <span class="string">tomcat</span></span><br><span class="line"><span class="attr">      release:</span> <span class="string">canary</span></span><br><span class="line"><span class="attr">  template:</span></span><br><span class="line"><span class="attr">    metadata:</span></span><br><span class="line"><span class="attr">      labels:</span></span><br><span class="line"><span class="attr">        app:</span> <span class="string">tomcat</span></span><br><span class="line"><span class="attr">        release:</span> <span class="string">canary</span></span><br><span class="line"><span class="attr">    spec:</span></span><br><span class="line"><span class="attr">      containers:</span></span><br><span class="line"><span class="attr">        - name:</span> <span class="string">tomcat</span></span><br><span class="line"><span class="attr">          image:</span> <span class="attr">tomcat:8.5.32-jre8-alpine</span></span><br><span class="line"><span class="attr">          ports:</span></span><br><span class="line"><span class="attr">            - name:</span> <span class="string">http</span></span><br><span class="line"><span class="attr">              containerPort:</span> <span class="number">8080</span></span><br><span class="line"><span class="attr">            - name:</span> <span class="string">ajp</span></span><br><span class="line"><span class="attr">              containerPort:</span> <span class="number">8009</span></span><br></pre></td></tr></table></figure>
<ul>
<li>制作自签名证书，让 ingress-nginx 带有证书来访问</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 生成 key</span></span><br><span class="line">openssl genrsa -out tls.key 2048</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成自签证书，CN=域名必须要与自己的域名完全一致</span></span><br><span class="line">openssl req -new -x509 -key tls.key -out tls.crt -subj /C=CN/ST=Beijing/L=Beijing/O=DevOps/CN=tomcat.jinheng.com</span><br></pre></td></tr></table></figure>
<ul>
<li>创建 secret 证书对象，它是标准的 k8s 对象</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl create secret tls tomcat-ingress-secret --cert=tls.crt --key=tls.key</span><br></pre></td></tr></table></figure>
<ul>
<li>创建带证书的 ingress 对象，它能将 ingress-tomcat 与 service 关联，从而在 service 后主机发生变动的时候，反应在 ingress-tomcat 这个容器的配置文件中</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">ingress-deploy-tomcat-tls</span></span><br><span class="line"><span class="attr">  namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">  annotations:</span></span><br><span class="line">    <span class="string">kubernetes.io/ingress.class:</span> <span class="string">"nginx"</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  tls:</span></span><br><span class="line"><span class="attr">    - hosts:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">tomcat.jinheng.com</span></span><br><span class="line"><span class="attr">      secretName:</span> <span class="string">tomcat-ingress-secret</span></span><br><span class="line"><span class="attr">  rules:</span></span><br><span class="line"><span class="attr">    - host:</span> <span class="string">tomcat.jinheng.com</span></span><br><span class="line"><span class="attr">      http:</span></span><br><span class="line"><span class="attr">        paths:</span></span><br><span class="line"><span class="attr">          - path:</span></span><br><span class="line"><span class="attr">            backend:</span></span><br><span class="line"><span class="attr">              serviceName:</span> <span class="string">service-ingress-tomcat</span></span><br><span class="line"><span class="attr">              servicePort:</span> <span class="number">8080</span></span><br></pre></td></tr></table></figure>
<ul>
<li>查看 ingress-nginx 对外暴露的端口，这里为30080，和 30443 两个</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get service -n ingress-nginx</span><br></pre></td></tr></table></figure>
<ul>
<li>使用 nodeip + ingress-nginx 暴露端口访问，由于上面创建的 ingress 为基于主机名称的，所以需要在访问时在 /etc/hosts 做好映射到 node。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">https://tomcat.jinheng.com:30443</span><br></pre></td></tr></table></figure>
<h1 id="POD-存储卷"><a href="#POD-存储卷" class="headerlink" title="POD 存储卷"></a>POD 存储卷</h1><p>大部分有状态的应用都有持久存储，在 Docker 上我们将容器所需要的存储卷放在宿主机上，但是 k8s 上不行，因为 POD 会被在不同的 node 节点上创建删除，所以 k8s 需要一套另外的存储卷机制，它能脱离节点为整个集群提供持久存储。</p>
<p>k8s 提供了多种不同的存储卷，k8s 中存储卷属于 POD 而不是容器，POD 可以挂载，POD 为什么能有存储卷呢？这是因为在所有节点上运行了一个 Pause 的镜像，它是 POD 的基础架构容器，它拥有存储卷，同一个 POD 内的所有容器是一个网络名称空间的。</p>
<h2 id="k8s-存储卷类型"><a href="#k8s-存储卷类型" class="headerlink" title="k8s 存储卷类型"></a>k8s 存储卷类型</h2><ol>
<li>EmptyDir：只在节点本地使用，一旦 POD 删除，存储卷也会删除，它不具有持久性，当临时目录或者缓存。</li>
<li>HostPath：在节点本地新建一个路径，与容器建立关联关系，但节点挂了的数据也不存在了，所以也不具有持久性。</li>
<li>网络存储：</li>
</ol>
<ul>
<li>SAN（存储区域网络）：iSCSI、NAS（网络附加存储）：NFS、Cifs</li>
<li>分布式存储：glusterfs（文件系统）、cephfs（块、文件系统、对象）</li>
<li>云端储存：EBS（AWS)、Disk（Azone）</li>
</ul>
<blockquote>
<p>  查看 POD 支持的存储类型：kubectl explain pods.spec.volumes</p>
</blockquote>
<ul>
<li>在 POD 中挂载使用各种存储卷，<code>kubectl explain pods.spec.containers.volumeMounts</code></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mountPath	      &lt;string&gt;    <span class="comment"># 挂载路径</span></span><br><span class="line">mountPropagation  &lt;string&gt;    <span class="comment"># 确定挂载如何从主机传播到容器</span></span><br><span class="line">name	          &lt;string&gt;    <span class="comment"># 挂载哪个卷</span></span><br><span class="line">readOnly	      &lt;boolean&gt;   <span class="comment"># 是否只读挂载</span></span><br><span class="line">subPath	          &lt;string&gt;    <span class="comment"># 挂载在子路径下</span></span><br><span class="line">subPathExpr	      &lt;string&gt;    <span class="comment"># 与 subPath 类似，挂载在子路径下，不同的是可以使用 $(VAR_NAME) 表示容器扩展这个变量</span></span><br></pre></td></tr></table></figure>
<h2 id="emptyDir"><a href="#emptyDir" class="headerlink" title="emptyDir"></a>emptyDir</h2><ul>
<li>定义 emptyDir 参数，<code>kubectl explain pods.spec.volumes.emptyDir</code></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">medium	&lt;string&gt;        <span class="comment"># 使用 "" 表示使用 Disk 来存储，使用 Memory 表示使用内存</span></span><br><span class="line">sizeLimit	&lt;string&gt;    <span class="comment"># 限制存储空间的大小</span></span><br></pre></td></tr></table></figure>
<ul>
<li>使用示例</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">pod-volume-demo</span></span><br><span class="line"><span class="attr">  namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">  labels:</span></span><br><span class="line"><span class="attr">    app:</span> <span class="string">myapp</span></span><br><span class="line"><span class="attr">    tier:</span> <span class="string">frontend</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">myapp</span></span><br><span class="line"><span class="attr">      image:</span> <span class="string">ikubernetes/myapp:v1</span></span><br><span class="line"><span class="attr">      imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line"><span class="attr">      volumeMounts:</span></span><br><span class="line"><span class="attr">        - name:</span> <span class="string">html</span></span><br><span class="line"><span class="attr">          mountPath:</span> <span class="string">/usr/share/nginx/html/</span></span><br><span class="line"><span class="attr">      ports:</span></span><br><span class="line"><span class="attr">        - name:</span> <span class="string">http</span></span><br><span class="line"><span class="attr">          containerPort:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">        - name:</span> <span class="string">https</span></span><br><span class="line"><span class="attr">          containerPort:</span> <span class="number">443</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">busybox</span></span><br><span class="line"><span class="attr">      image:</span> <span class="attr">busybox:latest</span></span><br><span class="line"><span class="attr">      imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line"><span class="attr">      volumeMounts:</span></span><br><span class="line"><span class="attr">        - name:</span> <span class="string">html</span></span><br><span class="line"><span class="attr">          mountPath:</span> <span class="string">/data/</span></span><br><span class="line"><span class="attr">      command:</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">"/bin/sh"</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">"-c"</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">"while true; do date &gt;&gt; /data/index.html; sleep 10; done"</span></span><br><span class="line"><span class="attr">  volumes:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">html</span></span><br><span class="line"><span class="attr">      emptyDir:</span></span><br><span class="line"><span class="attr">        medium:</span> <span class="string">""</span></span><br><span class="line"><span class="attr">        sizeLimit:</span> <span class="number">1536</span><span class="string">Mi</span></span><br></pre></td></tr></table></figure>
<h2 id="gitRepo"><a href="#gitRepo" class="headerlink" title="gitRepo"></a>gitRepo</h2><p>将 git 仓库的内容当作存储使用，在 POD 创建时候连接到仓库，并拉取仓库，并将它挂载到容器内当作一个存储卷。</p>
<p>它其实是建立在 emptyDir 的基础上，但是对卷的操作不会同步到 gitrepo 上。</p>
<h2 id="hostpath"><a href="#hostpath" class="headerlink" title="hostpath"></a>hostpath</h2><p>宿主机的路径挂载到 POD 上，它在 POD 删除后，这个数据是不会随之删除的，但是如果 node 这个节点挂掉，那么数据还是有可能丢失的，如果 POD 被调度到其他的节点，那么数据也会无法访问。</p>
<blockquote>
<p>  <a href="https://kubernetes.io/docs/concepts/storage/volumes/#hostpath" target="_blank" rel="noopener">https://kubernetes.io/docs/concepts/storage/volumes/#hostpath</a></p>
</blockquote>
<ul>
<li>定义参数，kubectl explain pods.spec.volumes.hostPath</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">path	&lt;string&gt;  <span class="comment"># 主机上目录的路径。 如果路径是符号链接，则会跟随真实路径的链接。</span></span><br><span class="line"><span class="built_in">type</span>	&lt;string&gt;  <span class="comment"># 见下表</span></span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align:left">值</th>
<th style="text-align:left">行为</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">空字符串（默认）用于向后兼容，这意味着在安装hostPath卷之前不会执行任何检查。</td>
</tr>
<tr>
<td style="text-align:left"><code>DirectoryOrCreate</code></td>
<td style="text-align:left">如果给定路径中不存在任何内容，则将根据需要创建一个空目录，权限设置为0755，与Kubelet具有相同的组和所有权。</td>
</tr>
<tr>
<td style="text-align:left"><code>Directory</code></td>
<td style="text-align:left">目录必须存在于给定路径中</td>
</tr>
<tr>
<td style="text-align:left"><code>FileOrCreate</code></td>
<td style="text-align:left">如果给定路径中不存在任何内容，则会根据需要创建一个空文件，权限设置为0644，与Kubelet具有相同的组和所有权。</td>
</tr>
<tr>
<td style="text-align:left"><code>File</code></td>
<td style="text-align:left">文件必须存在于给定路径中</td>
</tr>
<tr>
<td style="text-align:left"><code>Socket</code></td>
<td style="text-align:left">UNIX套接字必须存在于给定路径中</td>
</tr>
<tr>
<td style="text-align:left"><code>CharDevice</code></td>
<td style="text-align:left">字符设备必须存在于给定路径中</td>
</tr>
<tr>
<td style="text-align:left"><code>BlockDevice</code></td>
<td style="text-align:left">块设备必须存在于给定路径中</td>
</tr>
</tbody>
</table>
<h2 id="nfs"><a href="#nfs" class="headerlink" title="nfs"></a>nfs</h2><p>nfs 服务器是存在于集群之外的服务器，它不受 node 节点的影响，因而在 node 节点宕机后仍然能够提供持久存储给其他 POD。</p>
<ul>
<li>在 k8s 的 node 找一个主机，安装配置 nfs 服务器并启动</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ yum install nfs-utils                                                     <span class="comment"># 安装 nfs 服务</span></span><br><span class="line">$ mkdir -p /data/volumes                                                    <span class="comment"># 创建 volume 卷目录</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'/data/volumes  172.16.100.0/16(rw,no_root_squash)'</span> &gt;&gt; /etc/exports    <span class="comment"># 配置 nfs 服务器</span></span><br><span class="line">$ systemctl start nfs                                                       <span class="comment"># 启动 nfs 服务器</span></span><br><span class="line">$ ss -tnl                                                                   <span class="comment"># 确认监听端口，nfs 监听 TCP 2049 端口</span></span><br></pre></td></tr></table></figure>
<ul>
<li>在 k8s 集群的 node 节点安装 nfs 驱动，测试挂载是否正常</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ yum install nfs-utils</span><br><span class="line">$ mount -t nfs 172.16.100.104:/data/volumes /mnt</span><br></pre></td></tr></table></figure>
<ul>
<li>定义 nfs 参数，<code>kubectl explain pods.spec.volumes.nfs</code></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">path	  &lt;string&gt;       <span class="comment"># nfs 服务器的路径</span></span><br><span class="line">readOnly  &lt;boolean&gt;      <span class="comment"># 是否只读</span></span><br><span class="line">server	  &lt;string&gt;       <span class="comment"># nfs 服务器地址</span></span><br></pre></td></tr></table></figure>
<ul>
<li>使用示例</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">pod-vol-nfs-demo</span></span><br><span class="line"><span class="attr">  namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">myapp</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">ikubernetes/myapp:v1</span></span><br><span class="line"><span class="attr">    volumeMounts:</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">html</span></span><br><span class="line"><span class="attr">        mountPath:</span> <span class="string">/usr/share/nginx/html/</span></span><br><span class="line"><span class="attr">  volumes:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">html</span></span><br><span class="line"><span class="attr">      nfs:</span></span><br><span class="line"><span class="attr">        path:</span> <span class="string">/data/volumes</span></span><br><span class="line"><span class="attr">        server:</span> <span class="number">172.16</span><span class="number">.100</span><span class="number">.104</span></span><br></pre></td></tr></table></figure>
<h2 id="PersistentVolumeClaim"><a href="#PersistentVolumeClaim" class="headerlink" title="PersistentVolumeClaim"></a>PersistentVolumeClaim</h2><p>AWSElasticBlockStore、AzureFile、AzureDisk、CephFS、Cinder、FC、Flexvolume、Flocker、GCEPersistentDisk、Glusterfs、HostPath、iSCSI、Quobyte、NFS、RBD、VsphereVolume、PortworxVolume、ScaleIO、StorageOS</p>
<ul>
<li>使用 PVC，<code>kubectl explain pods.spec.volumes.persistentVolumeClaim</code></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">claimName	&lt;string&gt;  <span class="comment"># 在当前名称空间已经创建号的 PVC 名称</span></span><br><span class="line">readOnly	&lt;boolean&gt; <span class="comment"># 是否只读</span></span><br></pre></td></tr></table></figure>
<ul>
<li>定义 PVC，<code>kubectl explain PersistentVolumeClaim.spec</code></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">accessModes	&lt;[]string&gt;</span><br><span class="line">	<span class="comment"># ReadWriteOnce  - 卷可以由单个节点以读写方式挂载</span></span><br><span class="line">    <span class="comment"># ReadOnlyMany   - 卷可以由许多节点以只读方式挂载</span></span><br><span class="line">    <span class="comment"># ReadWriteMany  - 卷可以由许多节点以读写方式挂载</span></span><br><span class="line"></span><br><span class="line">dataSource	&lt;Object&gt;</span><br><span class="line">    <span class="comment"># 如果配置程序可以支持 Volume Snapshot 数据源，它将创建一个新卷，并且数据将同时还原到该卷。 </span></span><br><span class="line"></span><br><span class="line">resources	&lt;Object&gt;</span><br><span class="line">    <span class="comment"># 资源表示 PersistentVolume 应具有的最小资源</span></span><br><span class="line"></span><br><span class="line">selector	&lt;Object&gt;</span><br><span class="line">	<span class="comment"># 选择哪个 PersistentVolume</span></span><br><span class="line"></span><br><span class="line">storageClassName	&lt;string&gt;</span><br><span class="line">	<span class="comment"># 存储类名称</span></span><br><span class="line"></span><br><span class="line">volumeMode	&lt;string&gt;</span><br><span class="line">    <span class="comment"># 定义声明所需的 PersistentVolume 类型才能被选中</span></span><br><span class="line"></span><br><span class="line">volumeName	&lt;string&gt;</span><br><span class="line">	<span class="comment"># 后端 PersistentVolume ，就是精确选择 PersistentVolume ，而不是使用 selector 来选定</span></span><br></pre></td></tr></table></figure>
<h2 id="PersistentVolume"><a href="#PersistentVolume" class="headerlink" title="PersistentVolume"></a>PersistentVolume</h2><blockquote>
<p>  详见：kubectl explain PersistentVolume.spec</p>
</blockquote>
<ul>
<li>在 nfs 上定义存储，/etc/exports，并且导出 nfs 定义</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/data/volumes/v1    172.16.100.0/16(rw,no_root_squash)</span><br><span class="line">/data/volumes/v2    172.16.100.0/16(rw,no_root_squash)</span><br><span class="line">/data/volumes/v3    172.16.100.0/16(rw,no_root_squash)</span><br><span class="line">/data/volumes/v4    172.16.100.0/16(rw,no_root_squash)</span><br><span class="line">/data/volumes/v5    172.16.100.0/16(rw,no_root_squash)</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">exportfs -arv</span><br></pre></td></tr></table></figure>
<ul>
<li>将 nfs 在 k8s 中定义为 PersistentVolume，详见：kubectl explain PersistentVolume.spec.nfs</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolume</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">pv-001</span></span><br><span class="line"><span class="attr">  labels:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">pv001</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  accessModes:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">ReadWriteMany</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">ReadWriteOnce</span></span><br><span class="line"><span class="attr">  capacity:</span></span><br><span class="line"><span class="attr">    storage:</span> <span class="number">1</span><span class="string">Gi</span></span><br><span class="line"><span class="attr">  nfs:</span></span><br><span class="line"><span class="attr">    path:</span> <span class="string">/data/volumes/v1</span></span><br><span class="line"><span class="attr">    server:</span> <span class="number">172.16</span><span class="number">.100</span><span class="number">.104</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolume</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">pv-002</span></span><br><span class="line"><span class="attr">  labels:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">pv003</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  accessModes:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">ReadWriteMany</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">ReadWriteOnce</span></span><br><span class="line"><span class="attr">  capacity:</span></span><br><span class="line"><span class="attr">    storage:</span> <span class="number">2</span><span class="string">Gi</span></span><br><span class="line"><span class="attr">  nfs:</span></span><br><span class="line"><span class="attr">    path:</span> <span class="string">/data/volumes/v2</span></span><br><span class="line"><span class="attr">    server:</span> <span class="number">172.16</span><span class="number">.100</span><span class="number">.104</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolume</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">pv-003</span></span><br><span class="line"><span class="attr">  labels:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">pv003</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  accessModes:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">ReadWriteMany</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">ReadWriteOnce</span></span><br><span class="line"><span class="attr">  capacity:</span></span><br><span class="line"><span class="attr">    storage:</span> <span class="number">3</span><span class="string">Gi</span></span><br><span class="line"><span class="attr">  nfs:</span></span><br><span class="line"><span class="attr">    path:</span> <span class="string">/data/volumes/v3</span></span><br><span class="line"><span class="attr">    server:</span> <span class="number">172.16</span><span class="number">.100</span><span class="number">.104</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get persistentvolume</span><br><span class="line">NAME     CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS      CLAIM   STORAGECLASS   REASON   AGE</span><br><span class="line">pv-001   1Gi        RWO,RWX        Retain           Available                                   3m38s</span><br><span class="line">pv-002   2Gi        RWO,RWX        Retain           Available                                   3m38s</span><br><span class="line">pv-003   3Gi        RWO,RWX        Retain           Available                                   3m38s</span><br></pre></td></tr></table></figure>
<ul>
<li>定义 PersistentVolumeClaim，并在 pod中使用，详见：kubectl explain PersistentVolumeClaim.spec</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolumeClaim</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">my-pvc</span></span><br><span class="line"><span class="attr">  namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  accessModes:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">ReadWriteMany</span>        <span class="comment"># 访问模式</span></span><br><span class="line"><span class="attr">  resources:</span>               <span class="comment"># 资源条件</span></span><br><span class="line"><span class="attr">    requests:</span>              <span class="comment"># 挑选 PV 时候必须满足的条件，不满足则一直等待</span></span><br><span class="line"><span class="attr">      storage:</span> <span class="number">2</span><span class="string">Gi</span>         <span class="comment"># 存储大小</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">pod-vol-nfs-demo</span></span><br><span class="line"><span class="attr">  namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">myapp</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">ikubernetes/myapp:v1</span></span><br><span class="line"><span class="attr">    volumeMounts:</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">html</span></span><br><span class="line"><span class="attr">        mountPath:</span> <span class="string">/usr/share/nginx/html/</span></span><br><span class="line"><span class="attr">  volumes:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">html</span></span><br><span class="line"><span class="attr">      persistentVolumeClaim:</span></span><br><span class="line"><span class="attr">        claimName:</span> <span class="string">my-pvc</span>            <span class="comment"># 使用的 PVC 的名称</span></span><br></pre></td></tr></table></figure>
<h2 id="StorageClass"><a href="#StorageClass" class="headerlink" title="StorageClass"></a>StorageClass</h2><p>PVC 申请 PV 的时候，未必有符合条件的 PV，k8s 为我们准备了 StorageClass 可以在 PVC 申请 PV 的时候通过 StorageClass 动态生成 PV。</p>
<p>StorageClass 可以动态的到 CephFS 、NFS 等存储（或者云端存储）产生一个 PV，要求存储设备必须支持 RESTfull 风格的接口。</p>
<h1 id="配置信息容器化"><a href="#配置信息容器化" class="headerlink" title="配置信息容器化"></a>配置信息容器化</h1><p>k8s 提供了 configMap、secret 这两种特殊类型的存储卷，多数情况下不是为 POD 提供存储空间，而是为用户提供了从集群外部到 POD 内部注入配置信息的方式。</p>
<ul>
<li>配置信息容器化有哪些方式</li>
</ul>
<ol>
<li>自定义命令行参数，例如：command、args，根据 args 传递不同的参数来将容器运行为不同的特性</li>
<li>直接把配置信息制作为 image 中，但是这种方式非常不灵活，这个镜像只能适用于一种使用场景，过度耦合</li>
<li>环境变量，Cloud Native 支持通过环境变量来加载配置，或者使用 ENTRYPOINT 脚本来预处理环境变量为配置信息</li>
<li>存储卷，在容器启动时候挂载一个存储卷，或者专用的配置存储卷，挂载到应用程序的配置文件目录</li>
</ol>
<ul>
<li>Secret与ConfigMap对比</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">相同点：</span><br><span class="line">-   key / value 的形式 </span><br><span class="line">-   属于某个特定的 namespace </span><br><span class="line">-   可以导出到环境变量 </span><br><span class="line">-   可以通过目录/文件形式挂载(支持挂载所有key和部分key)</span><br><span class="line"></span><br><span class="line">不同点：</span><br><span class="line">-   Secret 可以被 ServerAccount 关联(使用) </span><br><span class="line">-   Secret 可以存储 register 的鉴权信息，用在 ImagePullSecret 参数中，用于拉取私有仓库的镜像 </span><br><span class="line">-   Secret 支持 Base64 加密 </span><br><span class="line">-   Secret 分为 kubernetes.io/Service Account，kubernetes.io/dockerconfigjson，Opaque三种类型, Configmap 不区分类型 </span><br><span class="line">-   Secret 文件存储在tmpfs文件系统中，Pod 删除后 Secret文件也会对应的删除。</span><br></pre></td></tr></table></figure>
<h2 id="POD-获取环境变量"><a href="#POD-获取环境变量" class="headerlink" title="POD 获取环境变量"></a>POD 获取环境变量</h2><ul>
<li>env，详见：kubectl explain pods.spec.containers.env</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">name</span>              <span class="string">&lt;string&gt;</span>  <span class="comment"># 变量名称</span></span><br><span class="line"><span class="string">value</span>	          <span class="string">&lt;string&gt;</span>  <span class="comment"># 变量的值</span></span><br><span class="line"><span class="string">valueFrom</span>         <span class="string">&lt;Object&gt;</span>  <span class="comment"># 引用值，如：configMap 的某个键、POD 定义中的字段名，如：metadata.labels</span></span><br><span class="line"><span class="string">resourceFieldRef</span>  <span class="string">&lt;Object&gt;</span>  <span class="comment"># 引用资源限制中的值</span></span><br><span class="line"><span class="string">secretKeyRef</span>      <span class="string">&lt;Object&gt;</span>  <span class="comment"># 引用 secretKey</span></span><br></pre></td></tr></table></figure>
<h2 id="configMap"><a href="#configMap" class="headerlink" title="configMap"></a>configMap</h2><p>假如我们现在要启动一个 POD ，这个 POD 启动时候，需要读取不同的配置信息，那么我们有两种方式：</p>
<ol>
<li>可以将 configMap 资源关联到当前 POD 上，POD 从 configMap 读取一个数据，传递给 POD 内部容器的一个变量，变量被注入后，可以重启容器。</li>
<li>可以将 configMap 资源挂载到当前 POD 上，作为一个文件系统的路径，这个目录正好是应用程序读取配置文件的路径，容器就可以读取到配置信息了，当 configMap 修改了，那么就会通知 POD ，POD 可以进行重载配置。</li>
</ol>
<p>在每个 configMap 中所有的配置信息都保存为键值的配置形式。</p>
<ul>
<li>清单格式，详见：kubectl explain configMap</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion	&lt;string&gt;              <span class="comment"># 版本号</span></span><br><span class="line">binaryData	&lt;map[string]string&gt;   <span class="comment"># 二进制的数据</span></span><br><span class="line">data	    &lt;map[string]string&gt;   <span class="comment"># 键值对的数据</span></span><br><span class="line">kind	    &lt;string&gt;              <span class="comment"># 对象类型</span></span><br><span class="line">metadata	&lt;Object&gt;              <span class="comment"># 对象元数据</span></span><br></pre></td></tr></table></figure>
<ul>
<li>命令行方式创建</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建名为 my-config 的 configMap，它的数据来自目录中的文件，键为文件名，值为文件内容</span></span><br><span class="line">kubectl create configmap my-config --from-file=path/to/dir</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建名为 my-config 的 configMap，它的数据来自文件中的键值对</span></span><br><span class="line">kubectl create configmap my-config --from-file=path/to/file</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建名为 my-config 的 configMap，也可以手动指定键的名称</span></span><br><span class="line">kubectl create configmap my-config --from-file=key1=/path/to/bar/file1.txt --from-file=key2=/path/to/bar/file2.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从字面量中创建</span></span><br><span class="line">kubectl create configmap my-config --from-literal=key1=config1 --from-literal=key2=config2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从env文件中命名 my-config</span></span><br><span class="line">kubectl create configmap my-config --from-env-file=path/to/bar.env</span><br></pre></td></tr></table></figure>
<h3 id="注入-POD-ENV"><a href="#注入-POD-ENV" class="headerlink" title="注入 POD ENV"></a>注入 POD ENV</h3><ul>
<li>创建 ConfigMap 并在 POD ENV 中使用</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span>                                        <span class="comment"># 创建 ConfigMap 对象</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">nginx-config</span></span><br><span class="line"><span class="attr">  namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line"><span class="attr">  server_name:</span> <span class="string">myapp.jinheng.com</span>                       <span class="comment"># 键值对数据</span></span><br><span class="line"><span class="attr">  nginx_port:</span> <span class="string">|                                        # 键值对数据，此处为 nginx 配置文件，需要注意换行的写法</span></span><br><span class="line"><span class="string">    server &#123;</span></span><br><span class="line"><span class="string">        server_name  myapp.jinheng.com;</span></span><br><span class="line"><span class="string">        listen  80;</span></span><br><span class="line"><span class="string">        root  /data/web/html;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">---</span></span><br><span class="line"><span class="string"></span><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">pod-configmap-demo</span></span><br><span class="line"><span class="attr">  namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">  labels:</span></span><br><span class="line"><span class="attr">    app:</span> <span class="string">myapp</span></span><br><span class="line"><span class="attr">    tier:</span> <span class="string">frontend</span></span><br><span class="line"><span class="attr">  annotations:</span></span><br><span class="line">    <span class="string">jinheng.com/created-by:</span> <span class="string">"cluster amdin"</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">myapp</span></span><br><span class="line"><span class="attr">      image:</span> <span class="string">ikubernetes/myapp:v1</span></span><br><span class="line"><span class="attr">      ports:</span></span><br><span class="line"><span class="attr">        - name:</span> <span class="string">http</span></span><br><span class="line"><span class="attr">          containerPort:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">      env:</span></span><br><span class="line"><span class="attr">        - name:</span> <span class="string">NGINX_SERVER_PORT</span>          <span class="comment"># 定义容器内变量的名字，容器需要在启动的时候使用 ENTRYPOINT 脚本将环境变量转换为应用的配置文件</span></span><br><span class="line"><span class="attr">          valueFrom:</span>                       <span class="comment"># 值来自于 configMap 对象中</span></span><br><span class="line"><span class="attr">            configMapKeyRef:</span>               <span class="comment"># 引用 configMap 对象</span></span><br><span class="line"><span class="attr">              name:</span> <span class="string">nginx-config</span>           <span class="comment"># configMap 对象的名字</span></span><br><span class="line"><span class="attr">              key:</span> <span class="string">nginx_port</span>              <span class="comment"># 引用 configMap 中的哪个 key</span></span><br><span class="line"><span class="attr">              optional:</span> <span class="literal">true</span>               <span class="comment"># 相对 POD 启动是否为可选，如果 configMap 中不存在这个值，true 则不阻塞 POD 启动</span></span><br><span class="line"><span class="attr">        - name:</span> <span class="string">NGINX_SERVER_NAME</span>          <span class="comment"># 定义容器内变量的名字，使用 exec 进入容器会发现变量已经在启动容器前注入容器内部了。</span></span><br><span class="line"><span class="attr">          valueFrom:</span></span><br><span class="line"><span class="attr">            configMapKeyRef:</span></span><br><span class="line"><span class="attr">              name:</span> <span class="string">nginx-config</span></span><br><span class="line"><span class="attr">              key:</span> <span class="string">server_name</span></span><br></pre></td></tr></table></figure>
<h3 id="挂载为-POD-卷"><a href="#挂载为-POD-卷" class="headerlink" title="挂载为 POD 卷"></a>挂载为 POD 卷</h3><ul>
<li>configMap 中的数据可以在容器内挂载为文件，并且当 configMap 中的数据发生变动的时候，容器内的文件相应也会发生变动，但不会重载容器内的进程。</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span>                                     <span class="comment"># 创建 ConfigMap</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">nginx-config-volumes</span></span><br><span class="line"><span class="attr">  namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">data:</span>                                               <span class="comment"># ConfigMap 中保存了两个数据，</span></span><br><span class="line"><span class="attr">  index:</span> <span class="string">|                                          # 数据1，它可以在 container 中使用 ENV 注入环境变量，也可以在 container 中使用 volumeMounts 挂载成为文件</span></span><br><span class="line"><span class="string">    &lt;h1&gt;this is a test page&lt;h1&gt;</span></span><br><span class="line"><span class="string"></span><span class="attr">  vhost:</span> <span class="string">|                                          # 数据2，它可以在 container 中使用 ENV 注入环境变量，也可以在 container 中使用 volumeMounts 挂载成为文件</span></span><br><span class="line"><span class="string">    server &#123;                                                                                                                                  </span></span><br><span class="line"><span class="string">        listen       80;                                                                                                                      </span></span><br><span class="line"><span class="string">        server_name  localhost;                                                                                                               </span></span><br><span class="line"><span class="string">                                                                                                                                              </span></span><br><span class="line"><span class="string">        location / &#123;                                                                                                                          </span></span><br><span class="line"><span class="string">            root   /usr/share/nginx/html;                                                                                                     </span></span><br><span class="line"><span class="string">            index  index.html index.htm;                                                                                                      </span></span><br><span class="line"><span class="string">        &#125;                                                                                                                                     </span></span><br><span class="line"><span class="string">                                                                                                                                              </span></span><br><span class="line"><span class="string">        error_page   500 502 503 504  /50x.html;                                                                                              </span></span><br><span class="line"><span class="string">        location = /50x.html &#123;                                                                                                                </span></span><br><span class="line"><span class="string">            root   /usr/share/nginx/html;                                                                                                     </span></span><br><span class="line"><span class="string">        &#125;                                                                                                                                     </span></span><br><span class="line"><span class="string">                                                                                                                                              </span></span><br><span class="line"><span class="string">        location = /hostname.html &#123;                                                                                                           </span></span><br><span class="line"><span class="string">            alias /etc/hostname;                                                                                                              </span></span><br><span class="line"><span class="string">        &#125;                                                                                                                                     </span></span><br><span class="line"><span class="string">    &#125; </span></span><br><span class="line"><span class="string">    server &#123;</span></span><br><span class="line"><span class="string">        server_name  myapp.jinheng.com;</span></span><br><span class="line"><span class="string">        listen  80;</span></span><br><span class="line"><span class="string">        root  /data/web/html;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">---</span></span><br><span class="line"><span class="string"></span><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">pod-configmap-volumes-demo</span></span><br><span class="line"><span class="attr">  namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">  labels:</span></span><br><span class="line"><span class="attr">    app:</span> <span class="string">myapp</span></span><br><span class="line"><span class="attr">    tier:</span> <span class="string">frontend</span></span><br><span class="line"><span class="attr">  annotations:</span></span><br><span class="line">    <span class="string">jinheng.com/created-by:</span> <span class="string">"cluster amdin"</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">myapp</span></span><br><span class="line"><span class="attr">      image:</span> <span class="string">ikubernetes/myapp:v1</span></span><br><span class="line"><span class="attr">      ports:</span></span><br><span class="line"><span class="attr">        - name:</span> <span class="string">http</span></span><br><span class="line"><span class="attr">          containerPort:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">      volumeMounts:</span></span><br><span class="line"><span class="attr">        - name:</span> <span class="string">nginx-conf</span></span><br><span class="line"><span class="attr">          mountPath:</span> <span class="string">/etc/nginx/conf.d</span></span><br><span class="line"><span class="attr">          readOnly:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">        - name:</span> <span class="string">nginx-page</span></span><br><span class="line"><span class="attr">          mountPath:</span> <span class="string">/data/web/html/</span></span><br><span class="line"><span class="attr">          readOnly:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  volumes:</span>                                               <span class="comment"># 定义卷</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">nginx-conf</span>                                   <span class="comment"># 定义卷的名字</span></span><br><span class="line"><span class="attr">      configMap:</span>                                         <span class="comment"># 该卷的类型为 configMap</span></span><br><span class="line"><span class="attr">        name:</span> <span class="string">nginx-config-volumes</span>                       <span class="comment"># 从命名空间中读取哪个名字的 configMap</span></span><br><span class="line"><span class="attr">        items:</span>                                           <span class="comment"># 定义 configMap 数据到文件的映射，如果不定义则使用 configMap 中的键为文件名称，值为文件内容</span></span><br><span class="line"><span class="attr">          - key:</span> <span class="string">vhost</span>                                   <span class="comment"># 使用 configMap 哪个键</span></span><br><span class="line"><span class="attr">            path:</span> <span class="string">www.conf</span>                               <span class="comment"># 将 configMap 中的数据，映射为容器内哪个文件名称</span></span><br><span class="line"><span class="attr">            mode:</span> <span class="number">644</span>                                    <span class="comment"># 指明文件的权限</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">nginx-page</span></span><br><span class="line"><span class="attr">      configMap:</span></span><br><span class="line"><span class="attr">        name:</span> <span class="string">nginx-config-volumes</span></span><br><span class="line"><span class="attr">        items:</span></span><br><span class="line"><span class="attr">          - key:</span> <span class="string">index</span></span><br><span class="line"><span class="attr">            path:</span> <span class="string">index.html</span></span><br><span class="line"><span class="attr">            mode:</span> <span class="number">644</span></span><br></pre></td></tr></table></figure>
<ul>
<li>启动后进入容器查看文件是否正常挂载</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl <span class="built_in">exec</span> -it pod-configmap-volumes-demo -c myapp -- /bin/sh</span><br></pre></td></tr></table></figure>
<ul>
<li>使用 curl 命令验证，是否能够正常使用</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ curl 10.244.2.104</span><br><span class="line">Hello MyApp | Version: v1 | &lt;a href=<span class="string">"hostname.html"</span>&gt;Pod Name&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">$ curl -H <span class="string">"Host:myapp.jinheng.com"</span> 10.244.2.104</span><br><span class="line">&lt;h1&gt;this is a <span class="built_in">test</span> page&lt;h1&gt;</span><br></pre></td></tr></table></figure>
<h2 id="secret"><a href="#secret" class="headerlink" title="secret"></a>secret</h2><p>configMap 是明文存储数据的，如果需要存储敏感数据，则需要使用 secret ，secret 与 configMap 的作用基本一致，且 secret 中的数据不是明文存放的，而是 base64 编码保存的。</p>
<ul>
<li>secret 类型</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker-registry    <span class="comment"># 创建一个 Docker registry 使用的 secret</span></span><br><span class="line">generic            <span class="comment"># 从本地文件，目录或字面值创建一个 secret</span></span><br><span class="line">tls                <span class="comment"># 创建一个 TLS  secret</span></span><br></pre></td></tr></table></figure>
<ul>
<li>清单格式，详见：kubectl explain secret</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion	&lt;string&gt;               <span class="comment"># API 版本</span></span><br><span class="line">data	    &lt;map[string]string&gt;    <span class="comment"># 以键值对列出数据，值需要经过 base64 加密</span></span><br><span class="line">kind	    &lt;string&gt;               <span class="comment"># 对象类型</span></span><br><span class="line">metadata	&lt;Object&gt;               <span class="comment"># 元数据</span></span><br><span class="line">stringData	&lt;map[string]string&gt;    <span class="comment"># 明文的数据</span></span><br><span class="line"><span class="built_in">type</span>	    &lt;string&gt;               <span class="comment"># 数据类型</span></span><br></pre></td></tr></table></figure>
<h3 id="私有仓库认证1"><a href="#私有仓库认证1" class="headerlink" title="私有仓库认证1"></a>私有仓库认证1</h3><ul>
<li>首先通过命令行创建出来 secret</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl create secret docker-registry regsecret --docker-server=registry-vpc.cn-hangzhou.aliyuncs.com --docker-username=admin --docker-password=123456 --docker-email=420123641@qq.com</span><br></pre></td></tr></table></figure>
<ul>
<li>如果想保存为文件可以</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get secret regsecret -o yaml</span><br></pre></td></tr></table></figure>
<ul>
<li>POD 创建时候，从 docker hub 拉取镜像使用的用户名密码，kubectl explain pods.spec 的 imagePullSecrets 字段</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">secret-file-pod</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">mypod</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">redis</span></span><br><span class="line"><span class="attr">  imagePullSecrets:</span>                         <span class="comment"># 获取镜像需要的用户名密码</span></span><br><span class="line"><span class="attr">   - name:</span> <span class="string">regsecret</span>                        <span class="comment"># secret 对象</span></span><br></pre></td></tr></table></figure>
<h3 id="私有仓库认证2"><a href="#私有仓库认证2" class="headerlink" title="私有仓库认证2"></a>私有仓库认证2</h3><ul>
<li>首先通过命令行创建出来 secret</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl create secret docker-registry regsecret --docker-server=registry-vpc.cn-hangzhou.aliyuncs.com --docker-username=admin --docker-password=123456 --docker-email=420123641@qq.com</span><br></pre></td></tr></table></figure>
<ul>
<li>创建自定义的 serviceaccount 对象，在 serviceaccount 对象上定义 image pull secrets</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">admin</span></span><br><span class="line"><span class="attr">  namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">imagePullSecrets:</span></span><br><span class="line"><span class="attr">- name:</span> <span class="string">regsecret</span>                       <span class="comment"># 指定 secret</span></span><br></pre></td></tr></table></figure>
<ul>
<li>创建 POD 使用指定的 serviceaccount 对象</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">pod-serviceaccount-demo</span></span><br><span class="line"><span class="attr">  namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">  labels:</span></span><br><span class="line"><span class="attr">    app:</span> <span class="string">myapp</span></span><br><span class="line"><span class="attr">    tier:</span> <span class="string">frontend</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">      image:</span> <span class="string">ikubernetes/myapp:v1</span></span><br><span class="line"><span class="attr">      ports:</span></span><br><span class="line"><span class="attr">        - name:</span> <span class="string">http</span></span><br><span class="line"><span class="attr">          containerPort:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">  serviceAccountName:</span> <span class="string">admin</span>                          <span class="comment"># 使用 serviceaccount 进行拉取镜像的认证，这样更加安全</span></span><br></pre></td></tr></table></figure>
<h3 id="创建-TLS-证书"><a href="#创建-TLS-证书" class="headerlink" title="创建 TLS 证书"></a>创建 TLS 证书</h3><ul>
<li>首先通过命令行创建出来</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl create secret tls nginx-secret --cert=tls.crt --key=tls.key</span><br></pre></td></tr></table></figure>
<ul>
<li>secret 中的数据可以在容器内挂载为文件，然后在 nginx 容器内使用证书文件</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">pod-configmap-volumes-demo</span></span><br><span class="line"><span class="attr">  namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">  labels:</span></span><br><span class="line"><span class="attr">    app:</span> <span class="string">myapp</span></span><br><span class="line"><span class="attr">    tier:</span> <span class="string">frontend</span></span><br><span class="line"><span class="attr">  annotations:</span></span><br><span class="line">    <span class="string">jinheng.com/created-by:</span> <span class="string">"cluster amdin"</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">myapp</span></span><br><span class="line"><span class="attr">      image:</span> <span class="string">ikubernetes/myapp:v1</span></span><br><span class="line"><span class="attr">      ports:</span></span><br><span class="line"><span class="attr">        - name:</span> <span class="string">http</span></span><br><span class="line"><span class="attr">          containerPort:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">      volumeMounts:</span></span><br><span class="line"><span class="attr">        - name:</span> <span class="string">nginx-conf</span></span><br><span class="line"><span class="attr">          mountPath:</span> <span class="string">/etc/nginx/secret</span></span><br><span class="line"><span class="attr">          readOnly:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  volumes:</span>                                               <span class="comment"># 定义卷</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">nginx-conf</span>                                   <span class="comment"># 定义卷的名字</span></span><br><span class="line"><span class="attr">      configMap:</span>                                         <span class="comment"># 该卷的类型为 secret</span></span><br><span class="line"><span class="attr">        name:</span> <span class="string">nginx-secret</span>                               <span class="comment"># 从命名空间中读取哪个名字的 secret</span></span><br><span class="line"><span class="attr">        items:</span>                                           <span class="comment"># 定义 secret 数据到文件的映射，如果不定义则使用 secret 中的键为文件名称，值为文件内容</span></span><br><span class="line"><span class="attr">          - key:</span> <span class="string">tls.key</span>                                 <span class="comment"># 使用 secret 哪个键</span></span><br><span class="line"><span class="attr">            path:</span> <span class="string">www.conf</span>                               <span class="comment"># 将 secret 中的数据，映射为容器内哪个文件名称</span></span><br><span class="line"><span class="attr">            mode:</span> <span class="number">644</span>                                    <span class="comment"># 指明文件的权限</span></span><br><span class="line"><span class="attr">          - key:</span> <span class="string">tls.crt</span></span><br><span class="line"><span class="attr">            path:</span> <span class="string">index.html</span></span><br><span class="line"><span class="attr">            mode:</span> <span class="number">644</span></span><br></pre></td></tr></table></figure>
<h1 id="StatefulSet-控制器"><a href="#StatefulSet-控制器" class="headerlink" title="StatefulSet 控制器"></a>StatefulSet 控制器</h1><p>StatefulSet 适用于有状态的应用，一般它管理的具有一下特点的 POD 资源</p>
<ol>
<li>稳定且唯一的网络标识符</li>
<li>稳定且持久的存储</li>
<li>有序、平滑的部署和扩展</li>
<li>有序、平滑的终止和删除</li>
<li>有序的滚动更新</li>
</ol>
<p>一个典型的 StatefulSet 应用一般包含三个组件：</p>
<ol>
<li>headless service （无头 service）</li>
<li>StatefulSet （控制器）</li>
<li>volumeClaimTemplate（存储卷申请模板）</li>
</ol>
<h2 id="清单格式"><a href="#清单格式" class="headerlink" title="清单格式"></a>清单格式</h2><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">podManagementPolicy</span>    <span class="string">&lt;string&gt;</span>      <span class="comment"># 控制扩展时候的顺序策略</span></span><br><span class="line"><span class="string">replicas</span>	           <span class="string">&lt;integer&gt;</span>     <span class="comment"># 模板运行的副本数</span></span><br><span class="line"><span class="string">revisionHistoryLimit</span>   <span class="string">&lt;integer&gt;</span>     <span class="comment"># 更新历史最大保存数量</span></span><br><span class="line"><span class="string">selector</span>               <span class="string">&lt;Object&gt;</span>      <span class="comment"># 标签选择器</span></span><br><span class="line"><span class="string">serviceName</span>            <span class="string">&lt;string&gt;</span>      <span class="comment"># headless service 的名称，基于这个 service 为 POD 分配标识符</span></span><br><span class="line"><span class="string">template</span>               <span class="string">&lt;Object&gt;</span>      <span class="comment"># POD 对象模板，需要配置挂载存储卷，应该使用 PCV 类型</span></span><br><span class="line"><span class="string">updateStrategy</span>         <span class="string">&lt;Object&gt;</span>      <span class="comment"># StatefulSet 更新策略</span></span><br><span class="line"><span class="string">volumeClaimTemplates</span>   <span class="string">&lt;[]Object&gt;</span>    <span class="comment"># pvs 的列表</span></span><br></pre></td></tr></table></figure>
<ul>
<li>POD 关联使用 PVC 逻辑</li>
</ul>
<p>每个 POD 中应该定义一个 PVC 类型的 volume ，这个 PVC 类型的 volume 应该关联到一个当前同一个名称空间的 PVC，这个 PVC 应该关联到集群级别的 PV 上。</p>
<p>statefullset 会为 POD 自动创建 PVC 类型的 Volume ，并且在 POD 所在的名称空间中自动创建 PVC。</p>
<h2 id="创建-NFS-PV"><a href="#创建-NFS-PV" class="headerlink" title="创建 NFS PV"></a>创建 NFS PV</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: PersistentVolume</span><br><span class="line">metadata:</span><br><span class="line">  name: pv-001</span><br><span class="line">  labels:</span><br><span class="line">    name: pv001</span><br><span class="line">spec:</span><br><span class="line">  accessModes:</span><br><span class="line">    - ReadWriteMany</span><br><span class="line">    - ReadWriteOnce</span><br><span class="line">  capacity:</span><br><span class="line">    storage: 5Gi</span><br><span class="line">  nfs:</span><br><span class="line">    path: /data/volumes/v1</span><br><span class="line">    server: 172.16.100.104</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: PersistentVolume</span><br><span class="line">metadata:</span><br><span class="line">  name: pv-002</span><br><span class="line">  labels:</span><br><span class="line">    name: pv003</span><br><span class="line">spec:</span><br><span class="line">  accessModes:</span><br><span class="line">    - ReadWriteMany</span><br><span class="line">    - ReadWriteOnce</span><br><span class="line">  capacity:</span><br><span class="line">    storage: 5Gi</span><br><span class="line">  nfs:</span><br><span class="line">    path: /data/volumes/v2</span><br><span class="line">    server: 172.16.100.104</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: PersistentVolume</span><br><span class="line">metadata:</span><br><span class="line">  name: pv-003</span><br><span class="line">  labels:</span><br><span class="line">    name: pv003</span><br><span class="line">spec:</span><br><span class="line">  accessModes:</span><br><span class="line">    - ReadWriteMany</span><br><span class="line">    - ReadWriteOnce</span><br><span class="line">  capacity:</span><br><span class="line">    storage: 5Gi</span><br><span class="line">  nfs:</span><br><span class="line">    path: /data/volumes/v3</span><br><span class="line">    server: 172.16.100.104</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: PersistentVolume</span><br><span class="line">metadata:</span><br><span class="line">  name: pv-004</span><br><span class="line">  labels:</span><br><span class="line">    name: pv004</span><br><span class="line">spec:</span><br><span class="line">  accessModes:</span><br><span class="line">    - ReadWriteMany</span><br><span class="line">    - ReadWriteOnce</span><br><span class="line">  capacity:</span><br><span class="line">    storage: 10Gi</span><br><span class="line">  nfs:</span><br><span class="line">    path: /data/volumes/v4</span><br><span class="line">    server: 172.16.100.104</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: PersistentVolume</span><br><span class="line">metadata:</span><br><span class="line">  name: pv-005</span><br><span class="line">  labels:</span><br><span class="line">    name: pv005</span><br><span class="line">spec:</span><br><span class="line">  accessModes:</span><br><span class="line">    - ReadWriteMany</span><br><span class="line">    - ReadWriteOnce</span><br><span class="line">  capacity:</span><br><span class="line">    storage: 10Gi</span><br><span class="line">  nfs:</span><br><span class="line">    path: /data/volumes/v5</span><br><span class="line">    server: 172.16.100.104</span><br></pre></td></tr></table></figure>
<h2 id="创建-statefulSet"><a href="#创建-statefulSet" class="headerlink" title="创建 statefulSet"></a>创建 statefulSet</h2><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">myapp</span></span><br><span class="line"><span class="attr">  labels:</span></span><br><span class="line"><span class="attr">    app:</span> <span class="string">myapp</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  ports:</span></span><br><span class="line"><span class="attr">    - port:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">      name:</span> <span class="string">web</span></span><br><span class="line"><span class="attr">  clusterIP:</span> <span class="string">None</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    app:</span> <span class="string">myapp-pod</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">StatefulSet</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">myapp</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  serviceName:</span> <span class="string">myapp</span></span><br><span class="line"><span class="attr">  replicas:</span> <span class="number">3</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    matchLabels:</span></span><br><span class="line"><span class="attr">      app:</span> <span class="string">myapp-pod</span></span><br><span class="line"><span class="attr">  template:</span></span><br><span class="line"><span class="attr">    metadata:</span></span><br><span class="line"><span class="attr">      labels:</span></span><br><span class="line"><span class="attr">        app:</span> <span class="string">myapp-pod</span></span><br><span class="line"><span class="attr">    spec:</span></span><br><span class="line"><span class="attr">      containers:</span></span><br><span class="line"><span class="attr">        - name:</span> <span class="string">myapp</span></span><br><span class="line"><span class="attr">          image:</span> <span class="string">ikubernetes/myapp:v1</span></span><br><span class="line"><span class="attr">          ports:</span></span><br><span class="line"><span class="attr">            - containerPort:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">              name:</span> <span class="string">web</span></span><br><span class="line"><span class="attr">          volumeMounts:</span></span><br><span class="line"><span class="attr">            - name:</span> <span class="string">myappdata</span></span><br><span class="line"><span class="attr">              mountPath:</span> <span class="string">/usr/share/nginx/html</span></span><br><span class="line"><span class="attr">  volumeClaimTemplates:</span></span><br><span class="line"><span class="attr">    - metadata:</span></span><br><span class="line"><span class="attr">        name:</span> <span class="string">myappdata</span></span><br><span class="line"><span class="attr">      spec:</span></span><br><span class="line"><span class="attr">        accessModes:</span></span><br><span class="line"><span class="bullet">          -</span> <span class="string">ReadWriteOnce</span></span><br><span class="line"><span class="attr">        resources:</span></span><br><span class="line"><span class="attr">          requests:</span></span><br><span class="line"><span class="attr">            storage:</span> <span class="number">5</span><span class="string">Gi</span></span><br></pre></td></tr></table></figure>
<ul>
<li>访问 pod</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pod_name.service_name.ns_name.svc.cluster.local</span><br></pre></td></tr></table></figure>
<h2 id="扩容和升级"><a href="#扩容和升级" class="headerlink" title="扩容和升级"></a>扩容和升级</h2><ul>
<li>扩容和缩容</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl scale sts myapp --replicas=5</span><br></pre></td></tr></table></figure>
<ul>
<li>升级策略，kubectl explain sts.spec.updateStrategy.rollingUpdate.partition</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">可以实现金丝雀发布，首先仅仅更新大于等于多少的部分，然后更新大于 0 的，就可以全部更新了</span><br><span class="line">kubectl patch sta myapp -p <span class="string">'&#123;"spec":&#123;"updateStrategy":&#123;"rollingUpdate":&#123;"partition":4&#125;&#125;&#125;&#125;'</span></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl <span class="built_in">set</span> image statefulset/myapp myapp=ikubernetes/myapp:v2kubectl</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl patch sta myapp -p <span class="string">'&#123;"spec":&#123;"updateStrategy":&#123;"rollingUpdate":&#123;"partition":0&#125;&#125;&#125;&#125;'</span></span><br></pre></td></tr></table></figure>
<h1 id="用户认证系统"><a href="#用户认证系统" class="headerlink" title="用户认证系统"></a>用户认证系统</h1><p>apiserver 是所有请求访问的网关接口，请求过程中，认证用于实现身份识别，授权用于实现权限检查，实际上，我们使用命令行：kubectl apply -f ment.yaml，实际上是转换为 HTTP 协议向 apiserver 发起请求的，而认证是信息由 ~/.kube/config 这个文件提供的，这个文件记录了管理员权限的用户信息。</p>
<ul>
<li>k8s 的 API 是 RESTfull 风格的，所以资源是由路径标明的，在 k8s 中，资源只能属于两个地方：属于集群 或 属于名称空间。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">集群级别：namespace、pv</span><br><span class="line">名称空间：POD、deployment、daemonSet、 service、PCV</span><br></pre></td></tr></table></figure>
<p>例如：请求 delfault 名称空间下的 myapp-deploy 控制器，就是下面的写法</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">http://172.16.100.100/apis/apps/v1/namespaces/default/deployments/myapp-deploy</span><br></pre></td></tr></table></figure>
<p>上面表示：<a href="http://172.16.100.100:6443" target="_blank" rel="noopener">http://172.16.100.100:6443</a> 集群的 apis 下的 apps 组的 v1 版本的 namespaces 下寻找 default 下的 myapp-deploy 控制器</p>
<h2 id="用户的类型"><a href="#用户的类型" class="headerlink" title="用户的类型"></a>用户的类型</h2><p>我们使用 kubectl 连接 k8s 集群进行控制，实际上是使用用户家目录下 .kube/config 这个文件中的用户连接到 apiserver 实现认证的，而有些 POD （如：CoreDNS）也需要获取集群的信息，它们也需要连接到 k8s 集群中，所以 k8s 中用户的类型有两种：</p>
<ol>
<li>人类使用的用户：useraccount，处于用户家目录 .kube/config 文件中，可使用 kubectl config –help 获取帮助创建</li>
<li>POD 使用的用户：serviceaccunt，是一种 k8s 对象，它可以使用 kubectl create serviceaccount –help 获取帮助创建</li>
</ol>
<h2 id="POD如何连接集群"><a href="#POD如何连接集群" class="headerlink" title="POD如何连接集群"></a>POD如何连接集群</h2><p>POD 需要使用 serviceaccount 连接并认证到集群，POD 之所以能够连接到集群是因为有一个内置的 service 将 POD 的请求代理至 apiserver 的地址了。</p>
<ul>
<li>名字为 kubernetes 的 servie 为 POD 连接到 apiserver 提供了通信</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ kubectl describe service kubernetes                            <span class="comment"># 集群内部的 POD 与 apiserver 通信使用的 service ，但是注意 apiserver 需要认证的</span></span><br><span class="line"></span><br><span class="line">Name:              kubernetes</span><br><span class="line">Namespace:         default</span><br><span class="line">Labels:            component=apiserver</span><br><span class="line">                   provider=kubernetes</span><br><span class="line">Annotations:       &lt;none&gt;</span><br><span class="line">Selector:          &lt;none&gt;</span><br><span class="line">Type:              ClusterIP</span><br><span class="line">IP:                10.96.0.1                                     <span class="comment"># 集群内部访问 apiserver 的网关</span></span><br><span class="line">Port:              https  443/TCP</span><br><span class="line">TargetPort:        6443/TCP</span><br><span class="line">Endpoints:         172.16.100.101:6443                           <span class="comment"># apiserver 工作的地址</span></span><br><span class="line">Session Affinity:  None</span><br><span class="line">Events:            &lt;none&gt;</span><br></pre></td></tr></table></figure>
<h2 id="serviceaccount-对象"><a href="#serviceaccount-对象" class="headerlink" title="serviceaccount 对象"></a>serviceaccount 对象</h2><p>k8s 的认证有两种一种是：human user、一种是 serviceaccount，下面就是创建 serviceaccount 它是 POD 访问 apiserver 所用的一种对象，而 human user，即使 kubectl 命令行通过读取 config 中的用户而认证到 apiserver 的。</p>
<ul>
<li>创建一个 serviceaccount 对象，它会自动创建并关联一个 secret，这个 serviceaccount 可以到 apiserver 上进行认证，但是认证不代表有权限，所以需要授权</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ kubectl create serviceaccount admin</span><br><span class="line">$ kubectl get secret</span><br></pre></td></tr></table></figure>
<ul>
<li>创建 POD 使用指定的 serviceaccount 对象</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">pod-serviceaccount-demo</span></span><br><span class="line"><span class="attr">  namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">  labels:</span></span><br><span class="line"><span class="attr">    app:</span> <span class="string">myapp</span></span><br><span class="line"><span class="attr">    tier:</span> <span class="string">frontend</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">      image:</span> <span class="string">ikubernetes/myapp:v1</span></span><br><span class="line"><span class="attr">      ports:</span></span><br><span class="line"><span class="attr">        - name:</span> <span class="string">http</span></span><br><span class="line"><span class="attr">          containerPort:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">  serviceAccountName:</span> <span class="string">admin</span></span><br></pre></td></tr></table></figure>
<h3 id="在-POD-中使用-serviceaccount"><a href="#在-POD-中使用-serviceaccount" class="headerlink" title="在 POD 中使用 serviceaccount"></a>在 POD 中使用 serviceaccount</h3><ul>
<li>POD 连接 apiserver 时候，需要在清单中指定 serviceAccountName 这个字段，详见：kubectl explain pods.spec</li>
</ul>
<p>每个 POD 默认自带一个 volumes，这是一个 secret，这个存储卷保存着 default-token-bq2gn 用来访问 apiserver ，而这个 secret 权限仅仅能通过 api 访问当前 POD 自身的信息，如果想要一个 POD 拥有管理集群的权限，那么可以手动创建一个 secret 并通过 volumes 挂载到 POD 上。</p>
<p>serviceaccout 也属于标准的 k8s 对象，这个对象提供了账号信息，但是账号由没有权限需要 rbac 机制来决定。</p>
<h2 id="kubectl-配置文件"><a href="#kubectl-配置文件" class="headerlink" title="kubectl 配置文件"></a>kubectl 配置文件</h2><ul>
<li>kubectl 配置文件解析，详见：kubectl config view</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Config</span></span><br><span class="line"><span class="attr">clusters:</span>                                             <span class="comment"># 集群列表</span></span><br><span class="line"><span class="attr">- cluster:</span>                                            <span class="comment"># 列表中的一个集群对象</span></span><br><span class="line"><span class="attr">    certificate-authority-data:</span> <span class="string">DATA+OMITTED</span>          <span class="comment"># 服务器认证方式</span></span><br><span class="line"><span class="attr">    server:</span> <span class="attr">https://172.16.100.101:6443</span>               <span class="comment"># 集群的 apiserver 地址</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">kubernetes</span>                                    <span class="comment"># 集群名称</span></span><br><span class="line"><span class="attr">users:</span>                                                <span class="comment"># 用户列表</span></span><br><span class="line"><span class="attr">- name:</span> <span class="string">kubernetes-admin</span>                              <span class="comment"># 列表中的一个用户对象</span></span><br><span class="line"><span class="attr">  user:</span>                                               <span class="comment"># </span></span><br><span class="line"><span class="attr">    client-certificate-data:</span> <span class="string">REDACTED</span>                 <span class="comment"># 客户端证书</span></span><br><span class="line"><span class="attr">    client-key-data:</span> <span class="string">REDACTED</span>                         <span class="comment"># 客户端私钥</span></span><br><span class="line"><span class="attr">contexts:</span>                                             <span class="comment"># 上下文列表</span></span><br><span class="line"><span class="attr">- context:</span>                                            <span class="comment"># 列表中的一个上下文对象</span></span><br><span class="line"><span class="attr">    cluster:</span> <span class="string">kubernetes</span>                               <span class="comment"># 集群名称</span></span><br><span class="line"><span class="attr">    user:</span> <span class="string">kubernetes-admin</span>                            <span class="comment"># 用户名称</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">kubernetes-admin@kubernetes</span>                   <span class="comment"># 上下文名称</span></span><br><span class="line"><span class="attr">current-context:</span> <span class="string">kubernetes-admin@kubernetes</span>          <span class="comment"># 当前上下文</span></span><br><span class="line"><span class="attr">preferences:</span> <span class="string">&#123;&#125;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>配置文件保存了：多个集群、多用户的配置，kubectl 可以使用不同的用户访问不同的集群。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">集群列表：集群对象列表</span><br><span class="line">用户列表：用户对象列表</span><br><span class="line">上下文：是描述集群与用户的关系列表。</span><br><span class="line">当前上下文：表示当前使用哪个用户访问哪个集群</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">自定义配置信息：详见：kubectl config  --<span class="built_in">help</span></span><br><span class="line">ca 和证书保存路径：/etc/kubernetes 保存了所有的 ca 和签发的证书信息。</span><br></pre></td></tr></table></figure>
<h2 id="添加证书用户到-config"><a href="#添加证书用户到-config" class="headerlink" title="添加证书用户到 config"></a>添加证书用户到 config</h2><p>k8s apiserver 认证方式有两种：ssl证书 和 token 认证，本次使用 ssl 证书创建用户</p>
<h3 id="创建SSL证书用户"><a href="#创建SSL证书用户" class="headerlink" title="创建SSL证书用户"></a>创建SSL证书用户</h3><ul>
<li>创建连接 apiserver 的用户证书</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建私钥</span></span><br><span class="line">(<span class="built_in">umask</span> 077; openssl genrsa -out jinheng.key 2048)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成证书签署请求，O 是组，CN 就是账号，这个账号被 k8s 用来识别身份，授权也需要授权这个账号</span></span><br><span class="line">openssl req -new -key jinheng.key -out jinheng.csr -subj <span class="string">"/CN=jinheng"</span></span><br><span class="line"><span class="comment">#penssl req -new -key jinheng.key -out jinheng.csr -subj "O=system:masters/CN=jinheng/"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 CA 签署证书，并且在 1800 天内有效</span></span><br><span class="line">openssl x509 -req -<span class="keyword">in</span> jinheng.csr -CA /etc/kubernetes/pki/ca.crt -CAkey /etc/kubernetes/pki/ca.key -CAcreateserial -out jinheng.crt -days 1800</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看证书</span></span><br><span class="line">openssl x509 -<span class="keyword">in</span> jinheng.crt -text -noout</span><br></pre></td></tr></table></figure>
<h3 id="添加SSL证书用户到config"><a href="#添加SSL证书用户到config" class="headerlink" title="添加SSL证书用户到config"></a>添加SSL证书用户到config</h3><ul>
<li>将 jinheng 用户添加到 k8s 的 config 中，设置客户端证书为 jinheng.crt，设置客户端私钥为：jinheng.key，使用 –embed-certs=true 来隐藏这些机密信息</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl config <span class="built_in">set</span>-credentials jinheng --client-certificate=./jinheng.crt --client-key=./jinheng.key --embed-certs=<span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h3 id="创建切换上下文"><a href="#创建切换上下文" class="headerlink" title="创建切换上下文"></a>创建切换上下文</h3><ul>
<li>创建上下文对象，授权 jinheng 用户访问名称为 kubernetes 的集群</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl config <span class="built_in">set</span>-context jinheng@kubernetes --cluster=kubernetes --user=jinheng</span><br></pre></td></tr></table></figure>
<ul>
<li>切换当前使用的上下文，到授权 jinheng 到 kubernetes 的上下文上</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl config use-context jinheng@kubernetes</span><br></pre></td></tr></table></figure>
<ul>
<li>由于这个用户没有授权，所以这个用户是无法 get 到信息的，可以再切换回来</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ kubectl get pods</span><br><span class="line">$ kubectl config use-context kubernetes-admin@kubernetes</span><br></pre></td></tr></table></figure>
<h2 id="创建新-config-文件"><a href="#创建新-config-文件" class="headerlink" title="创建新 config 文件"></a>创建新 config 文件</h2><p>使用 kubectl config set-cluster 创建一个新的 config 文件，想要设定这个新创建的 config 文件可以使用 –kubeconfig=/tmp/test.conf 指明。</p>
<ul>
<li>设置集群的连接的 ca 机构证书，–kubeconfig 可以指定 kubectl 使用的配置文件位置，默认为用户家目录 .kube 目录中的 config</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl config <span class="built_in">set</span>-cluster k8s-cluster --server=https://172.16.100.101:6443 --certificate-authority=/etc/kubernetes/pki/ca.crt --embed-certs=<span class="literal">true</span> --kubeconfig=/tmp/test.conf</span><br></pre></td></tr></table></figure>
<ul>
<li>将 jinheng 用户添加到 k8s 的 config 中，设置客户端证书为 jinheng.crt，设置客户端私钥为：jinheng.key，使用 –embed-certs=true 来隐藏这些机密信息</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl config <span class="built_in">set</span>-credentials jinheng --client-certificate=./jinheng.crt --client-key=./jinheng.key --embed-certs=<span class="literal">true</span></span><br></pre></td></tr></table></figure>
<ul>
<li>创建上下文对象，授权 jinheng 用户访问名称为 kubernetes 的集群</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl config <span class="built_in">set</span>-context def-ns-admin@k8s-cluster --cluster=k8s-cluster --user=def-ns-admin --kubeconfig=/tmp/test.conf</span><br></pre></td></tr></table></figure>
<ul>
<li>切换当前使用的上下文，到授权 jinheng 到 kubernetes 的上下文上</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl config use-context def-ns-admin@k8s-cluster --kubeconfig=/tmp/test.con</span><br></pre></td></tr></table></figure>
<h2 id="基于-token-认证"><a href="#基于-token-认证" class="headerlink" title="基于 token 认证"></a>基于 token 认证</h2><h3 id="创建-serviceaccount"><a href="#创建-serviceaccount" class="headerlink" title="创建 serviceaccount"></a>创建 serviceaccount</h3><ul>
<li>为 POD 创建一个 serviceaccount 对象，它是 POD 访问 apiserver 的凭证</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl create serviceaccount dashborad-admin -n kube-system</span><br></pre></td></tr></table></figure>
<h3 id="绑定集群管理员角色"><a href="#绑定集群管理员角色" class="headerlink" title="绑定集群管理员角色"></a>绑定集群管理员角色</h3><ul>
<li>创建 clusterrolebinding 将用户绑定至 cluster-admin 集群管理员（最高权限）</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl create clusterrolebinding dashborad-cluster-admin --clusterrole=cluster-admin --serviceaccount=kube-system:dashborad-admin</span><br></pre></td></tr></table></figure>
<h3 id="通过-serviceaccount-得到-Token"><a href="#通过-serviceaccount-得到-Token" class="headerlink" title="通过 serviceaccount 得到 Token"></a>通过 serviceaccount 得到 Token</h3><ul>
<li>找到刚才创建的 serviceaccount 对象</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get secret -n kube-system</span><br></pre></td></tr></table></figure>
<ul>
<li>得到 serviceaccount 对象中的 Token</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl describe secret -n kube-system dashborad-admin-token-skz95</span><br></pre></td></tr></table></figure>
<h1 id="用户权限系统"><a href="#用户权限系统" class="headerlink" title="用户权限系统"></a>用户权限系统</h1><p>在 k8s 中的用户权限系统是使用 RBAC 模式的，RBAC 是 Role-Based AC 的缩写，全称：基于角色的访问控制。</p>
<p>我们可以让一个用户扮演一个角色，而这个角色拥有权限，而这个用户就拥有了这个权限，所以在 RBAC 中，用户授权就是授权某个角色。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">用户（user）：用户可以拥有某个角色。</span><br><span class="line"></span><br><span class="line">角色（role）：角色可以拥有某些许可。</span><br><span class="line">	1. 操作</span><br><span class="line">	2. 对象</span><br><span class="line"></span><br><span class="line">许可（permission）： 在一个对象上能施加的操作组合起来，称之为一个许可权限。</span><br></pre></td></tr></table></figure>
<ul>
<li>用户类型</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Human User：              <span class="comment"># 用户账号</span></span><br><span class="line">Pod Service Account：     <span class="comment"># 服务账号</span></span><br></pre></td></tr></table></figure>
<ul>
<li>角色类型</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">- rule（角色）、rolebinding（角色绑定）</span><br><span class="line">- clausterrole（集群角色）、clusterrolebinding（集群角色绑定）</span><br></pre></td></tr></table></figure>
<ul>
<li>授权类型</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">- 用户通过 rolebinding 去 <span class="built_in">bind</span> rule，rolebinding 只能是当前命名空间中</span><br><span class="line">- 通过 clusterrolebinding 去 <span class="built_in">bind</span> clausterrole，clusterrolebinding会在所有名称空间生效</span><br><span class="line">- 通过 rolebinding 去 <span class="built_in">bind</span> clausterrole，由于 rolebinding 只在当前名称空间，所以 clausterrole 权限被限制为当前名称空间</span><br></pre></td></tr></table></figure>
<ul>
<li>通过 rolebinding 去 bind clausterrole 的好处</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">如果有很多名称空间、如果用 rolebinding 绑定 rule，那么则需要在每个名称空间都定义 role</span><br><span class="line">如果使用 rolebinding 绑定一个 clausterrole ，由于 clausterrole 拥有所有名称空间的权限，而 rolebinding  只能绑定当前名称空间，那么就省去为每个名称空间都新建一个 role 的过程了。</span><br></pre></td></tr></table></figure>
<h2 id="权限列表"><a href="#权限列表" class="headerlink" title="权限列表"></a>权限列表</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get clusterrole admin -o yaml</span><br></pre></td></tr></table></figure>
<h2 id="创建-Role"><a href="#创建-Role" class="headerlink" title="创建 Role"></a>创建 Role</h2><ul>
<li>命令行定义</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl create role pods-reader --verb=get,list,watch --resource=pods</span><br></pre></td></tr></table></figure>
<ul>
<li>使用清单方式定义</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Role</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">pods-reder</span></span><br><span class="line"><span class="attr">  namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line"><span class="attr">- apiGroups:</span>                           <span class="comment"># 对哪些 api 群组内的资源进行操作</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">""</span></span><br><span class="line"><span class="attr">  resources:</span>                           <span class="comment"># 对哪些资源授权</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">pods</span></span><br><span class="line"><span class="attr">  verbs:</span>                               <span class="comment"># 授权做哪些操作</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">get</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">list</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">watch</span></span><br></pre></td></tr></table></figure>
<h2 id="创建-rolebinding"><a href="#创建-rolebinding" class="headerlink" title="创建 rolebinding"></a>创建 rolebinding</h2><ul>
<li>使用 rolebinding 对象创建，用户与 role 的绑定</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl create rolebinding jinheng-read-pods --role=pods-reader --user=jinheng</span><br></pre></td></tr></table></figure>
<ul>
<li>使用清单方式定义</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">RoleBinding</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">jinheng-read-pods</span></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line"><span class="attr">  apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br><span class="line"><span class="attr">  kind:</span> <span class="string">Role</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">pods-reader</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line"><span class="attr">- apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br><span class="line"><span class="attr">  kind:</span> <span class="string">User</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">jinheng</span></span><br></pre></td></tr></table></figure>
<ul>
<li>切换用户和环境上下文</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ kubectl config use-context jinheng@kubernetes</span><br></pre></td></tr></table></figure>
<ul>
<li>测试用户是否拥有 get 权限</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get pods</span><br></pre></td></tr></table></figure>
<h2 id="创建-clusterrole"><a href="#创建-clusterrole" class="headerlink" title="创建 clusterrole"></a>创建 clusterrole</h2><ul>
<li>命令行定义</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl create clusterrole cluster-reader --verb=get,list,watch --resource=pods</span><br></pre></td></tr></table></figure>
<ul>
<li>使用清单方式定义</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: rbac.authorization.k8s.io/v1</span><br><span class="line">kind: ClusterRole</span><br><span class="line">metadata:</span><br><span class="line">  name: cluster-reader</span><br><span class="line">rules:</span><br><span class="line">- apiGroups:</span><br><span class="line">  - <span class="string">""</span></span><br><span class="line">  resources:</span><br><span class="line">  - pods</span><br><span class="line">  verbs:</span><br><span class="line">  - get</span><br><span class="line">  - list</span><br><span class="line">  - watch</span><br></pre></td></tr></table></figure>
<ul>
<li>系统内置有非常多的 clusterrole，详见：kubectl get clusterrole</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">NAME                                                                   AGE</span><br><span class="line">admin                                                                  5d16h</span><br><span class="line">cluster-admin                                                          5d16h</span><br><span class="line">cluster-reader                                                         4m32s</span><br><span class="line">edit                                                                   5d16h</span><br><span class="line">flannel                                                                5d6h</span><br><span class="line">system:aggregate-to-admin                                              5d16h</span><br><span class="line">system:aggregate-to-edit                                               5d16h</span><br><span class="line">system:aggregate-to-view                                               5d16h</span><br><span class="line">system:auth-delegator                                                  5d16h</span><br><span class="line">system:aws-cloud-provider                                              5d16h</span><br><span class="line">system:basic-user                                                      5d16h</span><br><span class="line">system:certificates.k8s.io:certificatesigningrequests:nodeclient       5d16h</span><br><span class="line">system:certificates.k8s.io:certificatesigningrequests:selfnodeclient   5d16h</span><br><span class="line">system:controller:attachdetach-controller                              5d16h</span><br><span class="line">system:controller:certificate-controller                               5d16h</span><br><span class="line">system:controller:clusterrole-aggregation-controller                   5d16h</span><br><span class="line">system:controller:cronjob-controller                                   5d16h</span><br><span class="line">system:controller:daemon-set-controller                                5d16h</span><br></pre></td></tr></table></figure>
<h2 id="创建-clusterrolebinding"><a href="#创建-clusterrolebinding" class="headerlink" title="创建 clusterrolebinding"></a>创建 clusterrolebinding</h2><ul>
<li>命令行定义</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl create clusterrolebinding jinheng-read-all-pods --clusterrole=cluster-reader --user=jinheng</span><br></pre></td></tr></table></figure>
<ul>
<li>清单定义</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRoleBinding</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">jinheng-read-all-pods</span></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line"><span class="attr">  apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br><span class="line"><span class="attr">  kind:</span> <span class="string">ClusterRole</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">cluster-reader</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line"><span class="attr">- apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br><span class="line"><span class="attr">  kind:</span> <span class="string">User</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">jinheng</span></span><br></pre></td></tr></table></figure>
<ul>
<li>切换用户和环境上下文</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ kubectl config use-context jinheng@kubernetes</span><br></pre></td></tr></table></figure>
<ul>
<li>测试用户是否拥有 get 权限</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ kubectl get pods -n kube-system</span><br><span class="line">$ kubectl config use-context kubernetes-admin@kubernetes</span><br></pre></td></tr></table></figure>
<h2 id="rolebinding-与-clusterrole"><a href="#rolebinding-与-clusterrole" class="headerlink" title="rolebinding 与 clusterrole"></a>rolebinding 与 clusterrole</h2><p>如果使用 rolebinding 绑定一个 clausterrole ，由于 clausterrole 拥有所有名称空间的权限，而 rolebinding  只能绑定当前名称空间，那么就省去为每个名称空间都新建一个 role 的过程了。</p>
<ul>
<li>命令定义</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ kubectl create rolebinding jinheng-cluster-reader --clusterrole=cluster-reader --user=jinheng</span><br></pre></td></tr></table></figure>
<ul>
<li>清单定义</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: rbac.authorization.k8s.io/v1</span><br><span class="line">kind: RoleBinding</span><br><span class="line">metadata:</span><br><span class="line">  name: jinheng-admin</span><br><span class="line">roleRef:</span><br><span class="line">  apiGroup: rbac.authorization.k8s.io</span><br><span class="line">  kind: ClusterRole</span><br><span class="line">  name: admin</span><br><span class="line">subjects:</span><br><span class="line">- apiGroup: rbac.authorization.k8s.io</span><br><span class="line">  kind: User</span><br><span class="line">  name: jinheng</span><br></pre></td></tr></table></figure>
<ul>
<li>切换用户和环境上下文</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ kubectl config use-context jinheng@kubernetes</span><br></pre></td></tr></table></figure>
<ul>
<li>测试用户是否拥有 get 权限，由于使用了 rolebinding ，所以 cluster-reader 被限制到当前命名空间</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ kubectl get pods -n kube-system</span><br><span class="line">$ kubectl config use-context kubernetes-admin@kubernetes</span><br></pre></td></tr></table></figure>
<h2 id="RBAC授权"><a href="#RBAC授权" class="headerlink" title="RBAC授权"></a>RBAC授权</h2><p>在 bind 授权的时候，可以绑定的用户主体有：user、group</p>
<ul>
<li>使用 rolebinding 和 clusterrolebinding 绑定</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">绑定到 user：表示只有这一个用户拥有 role 或者 clusterrole 的权限</span><br><span class="line">绑定到 group：表示这个组内的所有用户都具有了 role 或者 clusterrole 的权限</span><br></pre></td></tr></table></figure>
<ul>
<li>创建用户时候加入组，加入组后账户自动集成该组的权限</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建私钥</span></span><br><span class="line">(<span class="built_in">umask</span> 077; openssl genrsa -out jinheng.key 2048)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成证书签署请求，O 是组，CN 就是账号，这个账号被 k8s 用来识别身份，授权也需要授权这个账号</span></span><br><span class="line">openssl req -new -key jinheng.key -out jinheng.csr -subj <span class="string">"O=system:masters/CN=jinheng/"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 CA 签署证书，并且在 1800 天内有效</span></span><br><span class="line">openssl x509 -req -<span class="keyword">in</span> jinheng.csr -CA /etc/kubernetes/pki/ca.crt -CAkey /etc/kubernetes/pki/ca.key -CAcreateserial -out jinheng.crt -days 1800</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看证书</span></span><br><span class="line">openssl x509 -<span class="keyword">in</span> jinheng.crt -text -noout</span><br></pre></td></tr></table></figure>
<h1 id="dashboard"><a href="#dashboard" class="headerlink" title="dashboard"></a>dashboard</h1><p>它作为 k8s 集群的附件存在，是 kubernetes 官方的项目之一，详见：<a href="https://github.com/kubernetes/dashboard" target="_blank" rel="noopener">https://github.com/kubernetes/dashboard</a></p>
<h2 id="部署流程"><a href="#部署流程" class="headerlink" title="部署流程"></a>部署流程</h2><ul>
<li>为 dashboard 提供 ssl 证书</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 生成私钥</span></span><br><span class="line">(<span class="built_in">umask</span> 077; openssl genrsa -out dashboard.key 2048)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成一个自签证书，注意 CN 的值必须要与自己的域名完全一致</span></span><br><span class="line">openssl req -new -x509 -key dashboard.key -out dashboard.crt -subj <span class="string">"/O=dashboard/CN=k8s.dashboard.com"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看证书</span></span><br><span class="line">openssl x509 -<span class="keyword">in</span> dashboard.crt -text -noout</span><br></pre></td></tr></table></figure>
<ul>
<li>下载 dashboard 的清单文件</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">wget</span> <span class="attr">https://raw.githubusercontent.com/kubernetes/dashboard/v1.10.1/src/deploy/recommended/kubernetes-dashboard.yaml</span></span><br></pre></td></tr></table></figure>
<ul>
<li>为 dashboard 创建 secret 对象</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl -n kube-system create secret generic kubernetes-dashboard-certs --from-file=dashboard.crt=./dashboard.crt --from-file=dashboard.key=./dashboard.key</span><br></pre></td></tr></table></figure>
<ul>
<li>修改 dashboard 清单中 service 的工作模式为 nodeport</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed -i <span class="string">'/targetPort: 8443/a\ \ type: NodePort'</span> kubernetes-dashboard.yaml</span><br></pre></td></tr></table></figure>
<ul>
<li>注释掉 kubernetes-dashboard.yaml 清单文件中的 Dashboard Secret 这个证书的清单定义</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ------------------- Dashboard Secret ------------------- #</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#apiVersion: v1</span></span><br><span class="line"><span class="comment">#kind: Secret</span></span><br><span class="line"><span class="comment">#metadata:</span></span><br><span class="line"><span class="comment">#  labels:</span></span><br><span class="line"><span class="comment">#    k8s-app: kubernetes-dashboard</span></span><br><span class="line"><span class="comment">#  name: kubernetes-dashboard-certs</span></span><br><span class="line"><span class="comment">#  namespace: kube-system</span></span><br><span class="line"><span class="comment">#type: Opaque</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#---</span></span><br></pre></td></tr></table></figure>
<ul>
<li>部署 dashboard 清单</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f kubernetes-dashboard.yaml</span><br></pre></td></tr></table></figure>
<ul>
<li>取得 service 运行的端口</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get service -n kube-system</span><br></pre></td></tr></table></figure>
<ul>
<li>使用 chrome 访问 dashboard</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">https://172.16.100.102:31097/</span><br></pre></td></tr></table></figure>
<h2 id="使用令牌登录"><a href="#使用令牌登录" class="headerlink" title="使用令牌登录"></a>使用令牌登录</h2><ul>
<li>为 POD 创建一个 serviceaccount 对象，它是 POD 访问 apiserver 的凭证</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl create serviceaccount dashborad-admin -n kube-system</span><br></pre></td></tr></table></figure>
<ul>
<li>创建 clusterrolebinding 将用户绑定至 cluster-admin 集群管理员（最高权限）</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl create clusterrolebinding dashborad-cluster-admin --clusterrole=cluster-admin --serviceaccount=kube-system:dashborad-admin</span><br></pre></td></tr></table></figure>
<ul>
<li>找到刚才创建的 serviceaccount 对象</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get secret -n kube-system</span><br></pre></td></tr></table></figure>
<ul>
<li>得到 serviceaccount 对象中的 Token</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl describe secret -n kube-system dashborad-admin</span><br></pre></td></tr></table></figure>
<h2 id="分级管理"><a href="#分级管理" class="headerlink" title="分级管理"></a>分级管理</h2><p>现在需要创建一个只能管理 default 名称空间的用户，那么我们可以用 rolebinding 去绑定 admin 这个 clusterrolue 对象，那么就获得了当前名称空间的管理员权限了。</p>
<ul>
<li>创建 serviceaccount 登录</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl create serviceaccount def-ns-admin -n default</span><br></pre></td></tr></table></figure>
<ul>
<li>使用 rolebinding 对象，将 default 名称空间的 def-ns-admin 这个 serviceaccunt 与 admin 这个 clusterrole 绑定 </li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl create rolebinding def-ns-admin --clusterrole=admin --serviceaccount=default:def-ns-admin</span><br></pre></td></tr></table></figure>
<ul>
<li>找到刚才创建的 serviceaccount 对象</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get secret -n kube-system</span><br></pre></td></tr></table></figure>
<ul>
<li>得到 serviceaccount 对象中的 Token</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl describe secret def-ns-admin</span><br></pre></td></tr></table></figure>
<h2 id="配置文件认证"><a href="#配置文件认证" class="headerlink" title="配置文件认证"></a>配置文件认证</h2><p>与之前基于 SSL 证书的 config 文件不同，这次使用是基于 Token 的 config 文件，可以不用创建证书了，使用已有的 serviceaccount 对象的 token。</p>
<ul>
<li>设置集群的连接的 ca 机构证书，–kubeconfig 可以指定 kubectl 使用的配置文件位置，默认为用户家目录 .kube 目录中的 config</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl config <span class="built_in">set</span>-cluster k8s-cluster --server=https://172.16.100.101:6443 --certificate-authority=/etc/kubernetes/pki/ca.crt --embed-certs=<span class="literal">true</span> --kubeconfig=/tmp/test.conf</span><br></pre></td></tr></table></figure>
<ul>
<li>取得一个已经绑定角色的 serviceaccount 对象的 Token</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl describe secret def-ns-admin</span><br></pre></td></tr></table></figure>
<ul>
<li>使用 Token 来创建配置文件中的用户</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl config <span class="built_in">set</span>-credentials def-ns-admin --token=&lt;TOKEN&gt; --kubeconfig=/tmp/test.conf</span><br></pre></td></tr></table></figure>
<ul>
<li>创建上下文对象，授权 jinheng 用户访问名称为 kubernetes 的集群</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl config <span class="built_in">set</span>-context def-ns-admin@k8s-cluster --cluster=k8s-cluster --user=def-ns-admin --kubeconfig=/tmp/test.conf</span><br></pre></td></tr></table></figure>
<ul>
<li>切换当前使用的上下文，到授权 jinheng 到 kubernetes 的上下文上</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl config use-context def-ns-admin@k8s-cluster --kubeconfig=/tmp/test.conf</span><br></pre></td></tr></table></figure>
<ul>
<li>复制 /tmp/test.conf 这个文件到 dashboard 中就可以登录了</li>
</ul>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/03/20/personal/Hexo/" rel="next" title="Hexo 博客优化">
                <i class="fa fa-chevron-left"></i> Hexo 博客优化
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="lv-container" data-id="city" data-uid="MTAyMC80MzE1My8xOTY5OQ=="></div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="Jin Heng">
            
              <p class="site-author-name" itemprop="name">Jin Heng</p>
              <p class="site-description motion-element" itemprop="description">方向错了，越努力错的越离谱</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">58</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/yangjinheng" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:jinhengyang@foxmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          
        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Kubernetes简介"><span class="nav-number">1.</span> <span class="nav-text">Kubernetes简介</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#容器编排工具"><span class="nav-number">1.1.</span> <span class="nav-text">容器编排工具</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#自动化运维"><span class="nav-number">1.2.</span> <span class="nav-text">自动化运维</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#kubernetes"><span class="nav-number">1.3.</span> <span class="nav-text">kubernetes</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#环境架构"><span class="nav-number">1.4.</span> <span class="nav-text">环境架构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#组件总结"><span class="nav-number">1.5.</span> <span class="nav-text">组件总结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#组件和附件"><span class="nav-number">2.</span> <span class="nav-text">组件和附件</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Controller"><span class="nav-number">2.1.</span> <span class="nav-text">Controller</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Service"><span class="nav-number">2.2.</span> <span class="nav-text">Service</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#网络模型"><span class="nav-number">2.3.</span> <span class="nav-text">网络模型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#kube-proxy"><span class="nav-number">2.4.</span> <span class="nav-text">kube-proxy</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#etcd"><span class="nav-number">2.5.</span> <span class="nav-text">etcd</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#flanel"><span class="nav-number">2.6.</span> <span class="nav-text">flanel</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#知识小结"><span class="nav-number">2.7.</span> <span class="nav-text">知识小结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#安装集群"><span class="nav-number">3.</span> <span class="nav-text">安装集群</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#部署架构"><span class="nav-number">3.1.</span> <span class="nav-text">部署架构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#安装-Master"><span class="nav-number">3.2.</span> <span class="nav-text">安装 Master</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#配置-kuberetes-安装源"><span class="nav-number">3.2.1.</span> <span class="nav-text">配置 kuberetes 安装源</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#配置-docker-安装源"><span class="nav-number">3.2.2.</span> <span class="nav-text">配置 docker 安装源</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#安装-kubernetes"><span class="nav-number">3.2.3.</span> <span class="nav-text">安装 kubernetes</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#配置-Docker"><span class="nav-number">3.2.4.</span> <span class="nav-text">配置 Docker</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#配置-ipvs"><span class="nav-number">3.2.5.</span> <span class="nav-text">配置 ipvs</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#初始化-kubelet"><span class="nav-number">3.2.6.</span> <span class="nav-text">初始化 kubelet</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#部署-flannel"><span class="nav-number">3.2.7.</span> <span class="nav-text">部署 flannel</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#设置开机启动"><span class="nav-number">3.2.8.</span> <span class="nav-text">设置开机启动</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#安装-node"><span class="nav-number">3.3.</span> <span class="nav-text">安装 node</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#kubectl"><span class="nav-number">3.4.</span> <span class="nav-text">kubectl</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#入门命令"><span class="nav-number">4.</span> <span class="nav-text">入门命令</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#run"><span class="nav-number">4.1.</span> <span class="nav-text">run</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#run示例"><span class="nav-number">4.2.</span> <span class="nav-text">run示例</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#expose"><span class="nav-number">4.3.</span> <span class="nav-text">expose</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#coredns"><span class="nav-number">4.4.</span> <span class="nav-text">coredns</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#模拟-POD-被删除"><span class="nav-number">4.4.1.</span> <span class="nav-text">模拟 POD 被删除</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#模拟-service-被删除"><span class="nav-number">4.4.2.</span> <span class="nav-text">模拟 service 被删除</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#labels"><span class="nav-number">4.5.</span> <span class="nav-text">labels</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#动态扩容"><span class="nav-number">4.6.</span> <span class="nav-text">动态扩容</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#滚动升级"><span class="nav-number">4.7.</span> <span class="nav-text">滚动升级</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#集群外访问"><span class="nav-number">4.8.</span> <span class="nav-text">集群外访问</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#排查日志"><span class="nav-number">4.9.</span> <span class="nav-text">排查日志</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#连入-POD-容器"><span class="nav-number">4.10.</span> <span class="nav-text">连入 POD 容器</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#配置清单使用"><span class="nav-number">5.</span> <span class="nav-text">配置清单使用</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#可配置的对象"><span class="nav-number">5.1.</span> <span class="nav-text">可配置的对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#配置清单组成"><span class="nav-number">5.2.</span> <span class="nav-text">配置清单组成</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#获取清单帮助"><span class="nav-number">5.3.</span> <span class="nav-text">获取清单帮助</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#清单基本格式"><span class="nav-number">5.4.</span> <span class="nav-text">清单基本格式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#快捷获取清单"><span class="nav-number">5.5.</span> <span class="nav-text">快捷获取清单</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#create-创建"><span class="nav-number">5.6.</span> <span class="nav-text">create 创建</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#delete-删除"><span class="nav-number">5.7.</span> <span class="nav-text">delete 删除</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#applay-创建或更新"><span class="nav-number">5.8.</span> <span class="nav-text">applay 创建或更新</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#POD-配置清单"><span class="nav-number">6.</span> <span class="nav-text">POD 配置清单</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#pods-metadata-POD元数据"><span class="nav-number">6.1.</span> <span class="nav-text">pods.metadata POD元数据</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#labels-标签"><span class="nav-number">6.1.1.</span> <span class="nav-text">labels 标签</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#pods-spec-规范"><span class="nav-number">6.2.</span> <span class="nav-text">pods.spec 规范</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#nodeSelector-节点选择"><span class="nav-number">6.2.1.</span> <span class="nav-text">nodeSelector 节点选择</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#restartPolicy-POD重启策略"><span class="nav-number">6.2.2.</span> <span class="nav-text">restartPolicy POD重启策略</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#hostNetwork-主机网络空间"><span class="nav-number">6.2.3.</span> <span class="nav-text">hostNetwork 主机网络空间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#hostPID-主机PID空间"><span class="nav-number">6.2.4.</span> <span class="nav-text">hostPID 主机PID空间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#containers-配置"><span class="nav-number">6.2.5.</span> <span class="nav-text">containers 配置</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#imagePullPolicy下载策略"><span class="nav-number">6.2.5.1.</span> <span class="nav-text">imagePullPolicy下载策略</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ports-端口信息"><span class="nav-number">6.2.5.2.</span> <span class="nav-text">ports 端口信息</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#env-传递环境变量"><span class="nav-number">6.2.5.3.</span> <span class="nav-text">env 传递环境变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#command-ENTRYPOINT"><span class="nav-number">6.2.5.4.</span> <span class="nav-text">command ENTRYPOINT</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#args-CMD"><span class="nav-number">6.2.5.5.</span> <span class="nav-text">args CMD</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#annotations-注解信息"><span class="nav-number">6.2.5.6.</span> <span class="nav-text">annotations 注解信息</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#POD-生命周期"><span class="nav-number">6.2.5.7.</span> <span class="nav-text">POD 生命周期</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#livenessProbe-存活性探测"><span class="nav-number">6.2.5.8.</span> <span class="nav-text">livenessProbe 存活性探测</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#readinessProbe-就绪性检测"><span class="nav-number">6.2.5.9.</span> <span class="nav-text">readinessProbe 就绪性检测</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#lifecycle-生命周期钩子"><span class="nav-number">6.2.5.10.</span> <span class="nav-text">lifecycle 生命周期钩子</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#控制器配置清单"><span class="nav-number">7.</span> <span class="nav-text">控制器配置清单</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#ReplicaSet-控制器"><span class="nav-number">7.1.</span> <span class="nav-text">ReplicaSet 控制器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#replicaset-spec-规范"><span class="nav-number">7.1.1.</span> <span class="nav-text">replicaset.spec 规范</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#清单示例"><span class="nav-number">7.1.2.</span> <span class="nav-text">清单示例</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Deployment控制器"><span class="nav-number">7.2.</span> <span class="nav-text">Deployment控制器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#replicaset-spec-对象规范"><span class="nav-number">7.2.1.</span> <span class="nav-text">replicaset.spec 对象规范</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#清单示例-1"><span class="nav-number">7.2.2.</span> <span class="nav-text">清单示例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#关于更新"><span class="nav-number">7.2.3.</span> <span class="nav-text">关于更新</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#模拟金丝雀发布"><span class="nav-number">7.2.4.</span> <span class="nav-text">模拟金丝雀发布</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#更新策略"><span class="nav-number">7.2.5.</span> <span class="nav-text">更新策略</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#关于回滚"><span class="nav-number">7.2.6.</span> <span class="nav-text">关于回滚</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DaemonSet控制器"><span class="nav-number">7.3.</span> <span class="nav-text">DaemonSet控制器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#DaemonSet-spec规范"><span class="nav-number">7.3.1.</span> <span class="nav-text">DaemonSet.spec规范</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#清单示例-2"><span class="nav-number">7.3.2.</span> <span class="nav-text">清单示例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#关于更新-1"><span class="nav-number">7.3.3.</span> <span class="nav-text">关于更新</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Service-配置清单"><span class="nav-number">8.</span> <span class="nav-text">Service 配置清单</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Service-工作模式"><span class="nav-number">8.1.</span> <span class="nav-text">Service 工作模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Service-类型"><span class="nav-number">8.2.</span> <span class="nav-text">Service 类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#资源记录"><span class="nav-number">8.3.</span> <span class="nav-text">资源记录</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Service-清单"><span class="nav-number">8.4.</span> <span class="nav-text">Service 清单</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#service-spec-规范"><span class="nav-number">8.5.</span> <span class="nav-text">service.spec 规范</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ClusterIP-类型的-service"><span class="nav-number">8.6.</span> <span class="nav-text">ClusterIP 类型的 service</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NodePort-类型的-service"><span class="nav-number">8.7.</span> <span class="nav-text">NodePort 类型的 service</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#loadBalancerIP-类型"><span class="nav-number">8.8.</span> <span class="nav-text">loadBalancerIP 类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#无集群地址的-Service"><span class="nav-number">8.9.</span> <span class="nav-text">无集群地址的 Service</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#externalName-类型"><span class="nav-number">8.10.</span> <span class="nav-text">externalName 类型</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ingress-控制器"><span class="nav-number">9.</span> <span class="nav-text">ingress 控制器</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#ingress-spec-规范"><span class="nav-number">9.1.</span> <span class="nav-text">ingress.spec 规范</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ingress-nginx-代理"><span class="nav-number">9.2.</span> <span class="nav-text">ingress-nginx 代理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ingress-tomcat-代理"><span class="nav-number">9.3.</span> <span class="nav-text">ingress-tomcat 代理</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#POD-存储卷"><span class="nav-number">10.</span> <span class="nav-text">POD 存储卷</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#k8s-存储卷类型"><span class="nav-number">10.1.</span> <span class="nav-text">k8s 存储卷类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#emptyDir"><span class="nav-number">10.2.</span> <span class="nav-text">emptyDir</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#gitRepo"><span class="nav-number">10.3.</span> <span class="nav-text">gitRepo</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#hostpath"><span class="nav-number">10.4.</span> <span class="nav-text">hostpath</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#nfs"><span class="nav-number">10.5.</span> <span class="nav-text">nfs</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#PersistentVolumeClaim"><span class="nav-number">10.6.</span> <span class="nav-text">PersistentVolumeClaim</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#PersistentVolume"><span class="nav-number">10.7.</span> <span class="nav-text">PersistentVolume</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#StorageClass"><span class="nav-number">10.8.</span> <span class="nav-text">StorageClass</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#配置信息容器化"><span class="nav-number">11.</span> <span class="nav-text">配置信息容器化</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#POD-获取环境变量"><span class="nav-number">11.1.</span> <span class="nav-text">POD 获取环境变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#configMap"><span class="nav-number">11.2.</span> <span class="nav-text">configMap</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#注入-POD-ENV"><span class="nav-number">11.2.1.</span> <span class="nav-text">注入 POD ENV</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#挂载为-POD-卷"><span class="nav-number">11.2.2.</span> <span class="nav-text">挂载为 POD 卷</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#secret"><span class="nav-number">11.3.</span> <span class="nav-text">secret</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#私有仓库认证1"><span class="nav-number">11.3.1.</span> <span class="nav-text">私有仓库认证1</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#私有仓库认证2"><span class="nav-number">11.3.2.</span> <span class="nav-text">私有仓库认证2</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#创建-TLS-证书"><span class="nav-number">11.3.3.</span> <span class="nav-text">创建 TLS 证书</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#StatefulSet-控制器"><span class="nav-number">12.</span> <span class="nav-text">StatefulSet 控制器</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#清单格式"><span class="nav-number">12.1.</span> <span class="nav-text">清单格式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#创建-NFS-PV"><span class="nav-number">12.2.</span> <span class="nav-text">创建 NFS PV</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#创建-statefulSet"><span class="nav-number">12.3.</span> <span class="nav-text">创建 statefulSet</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#扩容和升级"><span class="nav-number">12.4.</span> <span class="nav-text">扩容和升级</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#用户认证系统"><span class="nav-number">13.</span> <span class="nav-text">用户认证系统</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#用户的类型"><span class="nav-number">13.1.</span> <span class="nav-text">用户的类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#POD如何连接集群"><span class="nav-number">13.2.</span> <span class="nav-text">POD如何连接集群</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#serviceaccount-对象"><span class="nav-number">13.3.</span> <span class="nav-text">serviceaccount 对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#在-POD-中使用-serviceaccount"><span class="nav-number">13.3.1.</span> <span class="nav-text">在 POD 中使用 serviceaccount</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#kubectl-配置文件"><span class="nav-number">13.4.</span> <span class="nav-text">kubectl 配置文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#添加证书用户到-config"><span class="nav-number">13.5.</span> <span class="nav-text">添加证书用户到 config</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#创建SSL证书用户"><span class="nav-number">13.5.1.</span> <span class="nav-text">创建SSL证书用户</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#添加SSL证书用户到config"><span class="nav-number">13.5.2.</span> <span class="nav-text">添加SSL证书用户到config</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#创建切换上下文"><span class="nav-number">13.5.3.</span> <span class="nav-text">创建切换上下文</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#创建新-config-文件"><span class="nav-number">13.6.</span> <span class="nav-text">创建新 config 文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#基于-token-认证"><span class="nav-number">13.7.</span> <span class="nav-text">基于 token 认证</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#创建-serviceaccount"><span class="nav-number">13.7.1.</span> <span class="nav-text">创建 serviceaccount</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#绑定集群管理员角色"><span class="nav-number">13.7.2.</span> <span class="nav-text">绑定集群管理员角色</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#通过-serviceaccount-得到-Token"><span class="nav-number">13.7.3.</span> <span class="nav-text">通过 serviceaccount 得到 Token</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#用户权限系统"><span class="nav-number">14.</span> <span class="nav-text">用户权限系统</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#权限列表"><span class="nav-number">14.1.</span> <span class="nav-text">权限列表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#创建-Role"><span class="nav-number">14.2.</span> <span class="nav-text">创建 Role</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#创建-rolebinding"><span class="nav-number">14.3.</span> <span class="nav-text">创建 rolebinding</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#创建-clusterrole"><span class="nav-number">14.4.</span> <span class="nav-text">创建 clusterrole</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#创建-clusterrolebinding"><span class="nav-number">14.5.</span> <span class="nav-text">创建 clusterrolebinding</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#rolebinding-与-clusterrole"><span class="nav-number">14.6.</span> <span class="nav-text">rolebinding 与 clusterrole</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RBAC授权"><span class="nav-number">14.7.</span> <span class="nav-text">RBAC授权</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#dashboard"><span class="nav-number">15.</span> <span class="nav-text">dashboard</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#部署流程"><span class="nav-number">15.1.</span> <span class="nav-text">部署流程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用令牌登录"><span class="nav-number">15.2.</span> <span class="nav-text">使用令牌登录</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#分级管理"><span class="nav-number">15.3.</span> <span class="nav-text">分级管理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#配置文件认证"><span class="nav-number">15.4.</span> <span class="nav-text">配置文件认证</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2017 &mdash; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jin Heng</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  
    <script type="text/javascript">
      (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
      })(document, 'script');
    </script>
  












  





  

  

  

  
  

  

  

  

</body>
</html>
